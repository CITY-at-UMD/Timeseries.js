{"version":3,"file":"index.modern.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n  let start = dayjs();\n  let end = dayjs().add(ms);\n  if (end.diff(start, \"year\", true) >= 1) {\n    return [\"year\", end.diff(start, \"year\")];\n  } else if (end.diff(start, \"month\", true) >= 1) {\n    return [\"month\", end.diff(start, \"month\")];\n  } else if (end.diff(start, \"day\", true) >= 1) {\n    return [\"day\", end.diff(start, \"day\")];\n  } else if (end.diff(start, \"hour\", true) >= 1) {\n    return [\"hour\", end.diff(start, \"hour\")];\n  } else {\n    return [\"minute\", end.diff(start, \"minute\")];\n  }\n};\n\nfunction calculateInterval(df, startDate, endDate) {\n  if (!startDate) startDate = df.first.date;\n  if (!endDate) endDate = df.last.date;\n  function computeInterval(window) {\n    return window.last() - window.first();\n  }\n  const intervals = df\n    .between(startDate, endDate)\n    .getIndex()\n    .window(2)\n    .select(computeInterval)\n    .detectValues()\n    .orderBy(row => row.Frequency);\n\n  let val = intervals.last().Value;\n  return msToInterval(val);\n}\nexport { msToInterval, calculateInterval };\n","import dayjs from \"dayjs\";\nimport _ from \"lodash\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration, true) /\n      durationValue\n  );\n\n  if (gapSize > 0) return true;\n  return false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize;\n  if (interval === \"quarterHour\") {\n    gapSize = Math.floor(\n      dayjs(endDate).diff(startDate, \"minutes\") / 15\n    );\n  } else {\n    gapSize = dayjs(endDate).diff(startDate, interval);\n  }\n  if (maxGap && maxGap > gapSize) return false;\n  if (gapSize > 0) return true;\n  return false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const newEntries = [];\n\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let date = dayjs(startDate)\n      .add((entryIndex + 1) * durationValue, duration)\n      .toDate();\n    newEntries.push([\n      date.valueOf(),\n      { date, value: null, ...(flag && { flag: [flag] }) }\n    ]);\n  }\n  return newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n  fillType,\n  { startValue, endValue, entryIndex, numEntries },\n  { overrideValue, dateFunction, date, flag }\n) => {\n  if (\n    [\n      \"pad\",\n      \"interpolate\",\n      \"average\",\n      \"dateFunction\",\n      \"value\"\n    ].indexOf(fillType) === -1\n  ) {\n    throw new Error(\"fill Type not supported\");\n  }\n  let value;\n  if (fillType === \"pad\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, startValue[key]];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", \"pad\"];\n  } else if (fillType === \"interpolate\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv =\n          startValue[key] +\n          (entryIndex + 1) *\n            ((endValue[key] - startValue[key]) /\n              (numEntries + 1));\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"average\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = (startValue[key] + endValue[key]) / numEntries;\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"dateFunction\" && dateFunction) {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = dateFunction(date);\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"value\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv;\n        if (typeof overrideValue === \"number\") {\n          nv = overrideValue;\n        } else {\n          nv = overrideValue[key];\n        }\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, null];\n      })\n    );\n    flag = [\"fill\"];\n  }\n  return { ...value, flag };\n};\n\nconst gapFill = (\n  fillType,\n  [duration, durationValue],\n  { overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n  // Fill values forward.\n\n  const startDate = dayjs(pairA[0]);\n  const endDate = dayjs(pairB[0]);\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const startValue = pairA[1];\n  const endValue = pairB[1];\n  const newEntries = [];\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let adjustment = valueFiller(\n        fillType,\n        { startValue, endValue, entryIndex, numEntries },\n        {\n          overrideValue,\n          dateFunction,\n          flag\n        }\n      ),\n      date = dayjs(startDate)\n        .add((entryIndex + 1) * durationValue, duration)\n        .toDate();\n    let e = [\n      date.valueOf(),\n      Object.assign({}, adjustment, { date })\n    ];\n    newEntries.push(e);\n  }\n\n  return newEntries;\n};\n\nexport {\n  gapExists,\n  gapFill,\n  gapFillBlank,\n  gapFillNull,\n  valueFiller\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\n\nclass Timeseries extends DataFrame {\n\tconstructor(data = []) {\n\t\tif (data instanceof DataFrame || data instanceof Timeseries) {\n\t\t\tdata = data.toArray();\n\t\t}\n\t\t// sort\n\t\tdata = data.sort(\n\t\t\t(a, b) => new Date(a.date).valueOf() - new Date(b.date).valueOf()\n\t\t);\n\t\tlet config = {\n\t\t\tvalues: data,\n\t\t\tindex: data.map(({ date }) => new Date(date).valueOf()),\n\t\t\tconsiderAllRows: true\n\t\t};\n\t\tsuper(config);\n\t}\n\tget interval() {\n\t\tlet startDate = this.first().date;\n\t\tlet endDate = this.last().date;\n\t\tfunction computeInterval(window) {\n\t\t\treturn window.last() - window.first();\n\t\t}\n\t\tconst intervals = this.between(startDate, endDate)\n\t\t\t.getIndex()\n\t\t\t.window(2)\n\t\t\t.select(computeInterval)\n\t\t\t.detectValues()\n\t\t\t.orderBy(row => row.Frequency)\n\t\t\t.orderBy(row => row.Value);\n\t\tlet val = intervals.last().Value;\n\t\treturn msToInterval(val);\n\t}\n\tdateRange(unit, adjustment) {\n\t\tlet start = dayjs(this.first().date),\n\t\t\tend = dayjs(this.last().date);\n\t\tif (adjustment) {\n\t\t\tstart = start.startOf(adjustment);\n\t\t\tend = end.endOf(adjustment);\n\t\t}\n\t\treturn end.diff(start, unit);\n\t}\n\tat(date) {\n\t\treturn super.at(new Date(date).valueOf());\n\t}\n\tcalculateThresholds({ k, filterZeros = true } = {}) {\n\t\tlet noflags = this.where(\n\t\t\trow =>\n\t\t\t\trow.flag === null ||\n\t\t\t\trow.flag === undefined ||\n\t\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t\t)\n\t\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t\t.getSeries(\"value\");\n\t\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\t\tif (!k) {\n\t\t\tk =\n\t\t\t\tnoflags.count() < 1000\n\t\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t\t}\n\t\tif (noflags.count() < 5) return {};\n\t\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\t\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\t\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\t\treturn { esd, box, modz };\n\t}\n\tremoveOutliers({ lowerThreshold, upperThreshold } = {}) {\n\t\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\t\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\t\tvalue < lowerThreshold || value > upperThreshold;\n\t\tlet df = this.generateSeries({\n\t\t\traw: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? row.value\n\t\t\t\t\t: null,\n\t\t\tflag: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? [\"outlier\"]\n\t\t\t\t\t: null\n\t\t}).transformSeries({\n\t\t\tvalue: value =>\n\t\t\t\toutlierCheck(value, lowerThreshold, upperThreshold) ? null : value\n\t\t});\n\t\treturn df;\n\t}\n\treset() {\n\t\treturn this.withSeries({\n\t\t\tvalue: row => (row.raw && !isNaN(row.raw) ? row.raw : row.value)\n\t\t}).dropSeries([\"flag\", \"raw\"]);\n\t}\n\tgroup(interval, toArray) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\t\tlet groups = this.groupBy(dateComparison);\n\t\treturn groups;\n\t}\n\t// Not Working Yet, downsample and upsample independently work\n\tresample([duration, value = 1], fillType) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet interval = this.interval;\n\t\tif (isEqual(interval, [duration, value])) {\n\t\t\treturn this;\n\t\t}\n\t\tlet d0 = dayjs(0);\n\t\tlet currentSampleDiff = dayjs(0)\n\t\t\t.add(interval[1], interval[0])\n\t\t\t.diff(d0);\n\t\tlet newSampleDiff = dayjs(0)\n\t\t\t.add(value, duration)\n\t\t\t.diff(d0);\n\t\tif (currentSampleDiff < newSampleDiff) {\n\t\t\treturn this.downsample([duration, value], fillType);\n\t\t} else {\n\t\t\treturn this.upsample([duration, value], fillType);\n\t\t}\n\t}\n\tupsample([duration, value], fillType = \"avg\") {\n\t\t// Dont use this b/c it has the raw and flag values\n\t\tlet df = this.fillGaps(\n\t\t\tgapExists([duration, value]),\n\t\t\tgapFill(fillType, [duration, value])\n\t\t);\n\t\treturn df;\n\t}\n\tdownsample([duration, value], fillType = \"sum\") {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t\t}\n\t\tlet dateComparison = row => dayjs(row.date).startOf(duration);\n\t\tif (value)\n\t\t\tdateComparison = row =>\n\t\t\t\tdayjs(row.date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.add(value, duration);\n\t\tlet df = this.groupBy(dateComparison)\n\t\t\t.select(group => {\n\t\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.toDate();\n\t\t\t\treturn {\n\t\t\t\t\tdate,\n\t\t\t\t\t...fromPairs(\n\t\t\t\t\t\tgroup\n\t\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).median();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).average();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).sum();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.withIndex(row => row.date.valueOf());\n\t\treturn df;\n\t}\n\tcalculateStatistics({\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = {}) {\n\t\tlet series = this.deflate(row => row[columnName]).where(\n\t\t\tvalue => !isNaN(value)\n\t\t);\n\t\tif (filterNegative) series = series.where(value => value >= 0);\n\t\tif (filterZeros) series = series.where(value => value !== 0);\n\t\tlet median = series.median();\n\t\tlet mean = series.average();\n\t\tlet count = series.count();\n\t\tlet std = series.std();\n\t\tlet min = series.min();\n\t\tlet max = series.max();\n\t\tlet mad = medianAbsoluteDeviation(series.toArray());\n\t\tlet q1 = quantile(series.toArray(), 0.25);\n\t\tlet q3 = quantile(series.toArray(), 0.75);\n\t\tlet iqr = q3 - q1;\n\t\tlet stats = {\n\t\t\tmedian,\n\t\t\tmean,\n\t\t\tcount,\n\t\t\tstd,\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tmad,\n\t\t\tq1,\n\t\t\tq3,\n\t\t\tiqr\n\t\t};\n\t\treturn stats;\n\t}\n\tdataQuality() {\n\t\tlet count = this.count();\n\t\tlet valid = this.getSeries(\"flag\")\n\t\t\t.where(\n\t\t\t\tvalue =>\n\t\t\t\t\tvalue === null ||\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t)\n\t\t\t.count();\n\t\tlet missing = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"missing\") !== -1)\n\t\t\t.count();\n\t\tlet invalid = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"outlier\") !== -1)\n\t\t\t.count();\n\t\tlet zeroFill = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"zeroFill\") !== -1)\n\t\t\t.count();\n\t\tlet breakdown = {\n\t\t\tvalid: valid / count,\n\t\t\tmissing: missing / count,\n\t\t\tinvalid: invalid / count\n\t\t};\n\t\tlet report = {\n\t\t\taccuracy: 0,\n\t\t\tcompleteness: 0,\n\t\t\tconsistency: 0\n\t\t};\n\t\treturn {};\n\t}\n\tpopulate(value, type = \"avg\") {\n\t\tlet v;\n\t\tswitch (type) {\n\t\t\tcase \"fill\":\n\t\t\t\tv = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = value / this.getIndex().count();\n\t\t\t\tbreak;\n\t\t}\n\t\tlet df = this.generateSeries({ value: row => v });\n\t\treturn df;\n\t}\n\tfill(interval, fillType) {\n\t\t// let interval = this.interval;\n\t\tif (!interval || !Array.isArray(interval)) interval = this.interval;\n\t\tlet ndf = this.fillGaps(gapExists(interval), gapFill(fillType, interval));\n\t\treturn new Timeseries(ndf);\n\t}\n\treduceToValue(columnNames) {\n\t\tfunction chooseValue(row, columnNames = []) {\n\t\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\t\treturn values[0] || 0;\n\t\t}\n\t\tlet df = this.generateSeries({\n\t\t\tvalue: row => chooseValue(row, columnNames)\n\t\t}).subset([\"date\", \"value\"]);\n\t\treturn new Timeseries(df);\n\t}\n\tclean(columnName = \"value\", { lowerThreshold, upperThreshold }) {\n\t\tlet arr = this.toArray().map(row => {\n\t\t\tlet value = row[columnName];\n\t\t\tif (value > upperThreshold || value < lowerThreshold) {\n\t\t\t\treturn { ...row, value: undefined, raw: value };\n\t\t\t} else {\n\t\t\t\treturn row;\n\t\t\t}\n\t\t});\n\t\treturn new Timeseries(arr);\n\t}\n\tstatic blank(startDate, endDate, [duration, value = 1]) {\n\t\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\t\tconsole.error(interval);\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\t}\n\t\tlet df = new Timeseries([\n\t\t\t{ date: new Date(startDate) },\n\t\t\t{ date: new Date(endDate) }\n\t\t])\n\t\t\t.fillGaps(gapExists([duration, value]), gapFillBlank([duration, value]))\n\t\t\t.between(startDate, endDate);\n\t\treturn new Timeseries(df);\n\t}\n\tstatic aggregate(dataframes) {\n\t\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\t\tdataframes = dataframes.map(df => new Timeseries(df));\n\t\tconst concatenated = DataFrame.concat(dataframes)\n\t\t\t.groupBy(row => row.date)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date;\n\t\t\t\tlet o = { date };\n\t\t\t\tgroup\n\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t.filter(c => c !== \"date\")\n\t\t\t\t\t.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\t\treturn o;\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.toArray();\n\t\treturn new Timeseries(concatenated);\n\t}\n\t// Models\n\tannualMonthlyAverage({ startDate, endDate }) {\n\t\tlet months = this.downsample([\"month\", 1], \"sum\").between(\n\t\t\tstartDate,\n\t\t\tendDate\n\t\t);\n\t\tlet avg = months.getSeries(\"value\").average();\n\t}\n}\nexport default Timeseries;\n"],"names":["msToInterval","ms","start","dayjs","end","add","diff","gapExists","duration","durationValue","pairA","pairB","startDate","Math","floor","gapFillBlank","flag","numEntries","newEntries","entryIndex","date","toDate","push","valueOf","value","valueFiller","fillType","startValue","endValue","overrideValue","dateFunction","indexOf","Error","fromPairs","toPairs","map","key","val","gapFill","endDate","adjustment","e","Object","assign","Timeseries","DataFrame","constructor","data","toArray","super","values","sort","a","b","Date","index","considerAllRows","interval","this","first","last","between","getIndex","window","select","detectValues","orderBy","row","Frequency","Value","dateRange","unit","startOf","endOf","at","calculateThresholds","k","filterZeros","noflags","where","Array","isArray","length","isNaN","getSeries","count","min","thresholds","esd","rosnerTest","box","boxPlotTest","modz","modifiedZScoreTest","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","generateSeries","raw","transformSeries","reset","withSeries","dropSeries","group","groupBy","resample","isEqual","d0","downsample","upsample","fillGaps","dateComparison","getColumnNames","filter","col","deflate","median","average","sum","inflate","withIndex","calculateStatistics","column","filterNegative","series","columnName","mean","std","max","mad","medianAbsoluteDeviation","q1","quantile","q3","iqr","dataQuality","populate","type","v","fill","ndf","reduceToValue","columnNames","df","n","chooseValue","subset","clean","arr","undefined","[object Object]","console","error","dataframes","concatenated","concat","o","c","forEach","annualMonthlyAverage"],"mappings":"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"}
{"version":3,"file":"index.modern.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/lib/Timeseries.statistics.js","../src/index.js","../src/lib/misc.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\nconst intervalToMS = ([unit, value]) => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(value, unit);\n\treturn end.diff(start);\n};\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, intervalToMS, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nimport { mean } from \"simple-statistics\";\nimport { Timeseries } from \"../index\";\nconst gapExists = ([duration, durationValue = 1]) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration, true) / durationValue\n\t);\n\n\tif (gapSize > 0) return true;\n\treturn false;\n};\n\nconst valueFiller = (\n\tfillType,\n\t{ startValue, endValue, entryIndex, numEntries },\n\t{ overrideValue, dateFunction, date, flag }\n) => {\n\tif (\n\t\t[\"pad\", \"interpolate\", \"average\", \"dateFunction\", \"value\"].indexOf(\n\t\t\tfillType\n\t\t) === -1\n\t) {\n\t\tthrow new Error(\"fill Type not supported\");\n\t}\n\tlet value;\n\tif (fillType === \"pad\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, startValue[key]];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", \"pad\"];\n\t} else if (fillType === \"interpolate\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv =\n\t\t\t\t\tstartValue[key] +\n\t\t\t\t\t(entryIndex + 1) *\n\t\t\t\t\t\t((endValue[key] - startValue[key]) / (numEntries + 1));\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"average\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = (startValue[key] + endValue[key]) / numEntries;\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"dateFunction\" && dateFunction) {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = dateFunction(date);\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"value\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv;\n\t\t\t\tif (typeof overrideValue === \"number\") {\n\t\t\t\t\tnv = overrideValue;\n\t\t\t\t} else {\n\t\t\t\t\tnv = overrideValue[key];\n\t\t\t\t}\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, null];\n\t\t\t})\n\t\t);\n\t\tflag = [\"fill\"];\n\t}\n\treturn { ...value, flag };\n};\n\nconst gapFill = (\n\tfillType,\n\t[duration, durationValue],\n\t{ overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n\t// Fill values forward.\n\n\tconst startDate = dayjs(pairA[0]);\n\tconst endDate = dayjs(pairB[0]);\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst startValue = pairA[1];\n\tconst endValue = pairB[1];\n\tconst newEntries = [];\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet adjustment = valueFiller(\n\t\t\t\tfillType,\n\t\t\t\t{ startValue, endValue, entryIndex, numEntries },\n\t\t\t\t{\n\t\t\t\t\toverrideValue,\n\t\t\t\t\tdateFunction,\n\t\t\t\t\tflag\n\t\t\t\t}\n\t\t\t),\n\t\t\tdate = dayjs(startDate)\n\t\t\t\t.add((entryIndex + 1) * durationValue, duration)\n\t\t\t\t.toDate();\n\t\tlet e = [date.valueOf(), Object.assign({}, adjustment, { date })];\n\t\tnewEntries.push(e);\n\t}\n\n\treturn newEntries;\n};\n\n// Basic Fill Functions\nconst averageMonthlyMap = df => {\n\tlet data = df.group(\"month\").select(group => ({\n\t\tmonth: group.first().date.month(),\n\t\tvalue: group\n\t\t\t.getSeries(\"value\")\n\t\t\t.where(v => v)\n\t\t\t.average()\n\t}));\n\tlet m = new Map(data.toArray().map(({ month, value }) => [month, value]));\n\tlet avg = data.getSeries(\"value\").average();\n\tm.set(\"default\", avg);\n\treturn m;\n};\n\nconst annualMonthlyAverageMap = df => {\n\tlet data = df\n\t\t.groupBy(row => row.date.year())\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(\"year\");\n\t\t\tlet ts = new Timeseries(group).downsample([\"month\", 1], \"avg\");\n\t\t\tlet avg = ts.getSeries(\"value\").average();\n\t\t\tlet map = averageMonthlyMap(ts);\n\t\t\tmap.set(\"avg\", avg);\n\t\t\treturn [date.year(), map];\n\t\t});\n\tlet m = new Map(data.toArray());\n\t// let deafult =\n\treturn m;\n};\n\nconst monthlyRollingAverageMap = (\n\tdf,\n\t{ years = 3, series = \"value\", aggregator = \"average\", validOnly = true } = {}\n) => {\n\tlet months = df\n\t\t.groupBy(row => row.date.startOf(\"month\").toDate())\n\t\t.select(group => {\n\t\t\tlet date = group.first().date.startOf(\"month\");\n\t\t\tlet value = group\n\t\t\t\t.getSeries(series)\n\t\t\t\t.where(v => (validOnly ? Boolean(v) : true))\n\t\t\t\t.average();\n\t\t\treturn { date, value };\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => row.date.toDate())\n\t\t.bake();\n\tlet data = months\n\t\t.groupBy(row => row.date.month())\n\t\t.select(group => {\n\t\t\tlet values = new Map(\n\t\t\t\tgroup.rollingWindow(years).select(window => [\n\t\t\t\t\twindow.last().date.year(),\n\t\t\t\t\twindow\n\t\t\t\t\t\t.getSeries(series)\n\t\t\t\t\t\t.where(v => (validOnly ? Boolean(v) : true))\n\t\t\t\t\t\t.average() ||\n\t\t\t\t\t\tgroup\n\t\t\t\t\t\t\t.getSeries(series)\n\t\t\t\t\t\t\t.where(v => (validOnly ? Boolean(v) : true))\n\t\t\t\t\t\t\t.average()\n\t\t\t\t])\n\t\t\t);\n\t\t\tgroup\n\t\t\t\t.where(row => !values.has(row.date.year()))\n\t\t\t\t.forEach(row => {\n\t\t\t\t\tlet value =\n\t\t\t\t\t\tmonths.before(row.date.toDate()).count() > 0\n\t\t\t\t\t\t\t? months.before(row.date.toDate()).last()[series]\n\t\t\t\t\t\t\t: months.getSeries(series).average();\n\t\t\t\t\tvalues.set(row.date.year(), value);\n\t\t\t\t});\n\n\t\t\tlet month = group.first().date.month();\n\t\t\treturn [month, values];\n\t\t});\n\n\treturn new Map(data.toArray());\n};\n\nconst fillMonthlyByMap = monthMap => row => monthMap.get(row.date.month());\nconst fillMonthlyBAnnualyMap = annualMonthlyMap => row => {\n\tlet month = row.date.month(),\n\t\tyear = row.date.year();\n\tif (annualMonthlyMap.has(month)) {\n\t\tif (annualMonthlyMap.has(month)) {\n\t\t\treturn annualMonthlyMap.get(month).get(year);\n\t\t} else {\n\t\t\treturn mean([...annualMonthlyMap.get(month).values()]);\n\t\t}\n\t} else {\n\t\treturn mean(\n\t\t\t[...annualMonthlyMap.values()].map(m =>\n\t\t\t\t[...m.values()].reduce((a, b) => a.concat(b), [])\n\t\t\t)\n\t\t);\n\t}\n};\n\nconst pad = (df, { validOnly = true, series = \"value\" } = {}) => row => {\n\tlet values = df\n\t\t.before(row.date.toDate())\n\t\t.getSeries(series)\n\t\t.where(v => v);\n\tlet value = values.count() > 0 ? values.last() : 0;\n\treturn value;\n};\nconst annualAverage = (\n\tdf,\n\t{ validOnly = true, series = \"value\", years = 3, defaultValue } = {}\n) => row => {\n\tlet subset = df\n\t\t.subset([\"date\", series])\n\t\t.after(row.date.subtract(years, \"year\").toDate())\n\t\t.before(row.date.toDate())\n\t\t.bake();\n\tlet values = subset\n\t\t.where(r => r.date.month() === row.date.month())\n\t\t.where(r => r.date.date() === row.date.date())\n\t\t.where(r => r.date.hour() === row.date.hour())\n\t\t.where(r => r.date.minute() === row.date.minute())\n\t\t.getSeries(series)\n\t\t.where(v => v);\n\n\tlet value;\n\tif (values.count() < years) {\n\t\tvalue = values\n\t\t\t.appendPair([\n\t\t\t\tnull,\n\t\t\t\tsubset\n\t\t\t\t\t.getSeries(series)\n\t\t\t\t\t.where(v => v)\n\t\t\t\t\t.average()\n\t\t\t])\n\t\t\t.average();\n\t} else {\n\t\tvalue = values.average();\n\t}\n\treturn value;\n};\nexport {\n\tgapExists,\n\tgapFill,\n\taverageMonthlyMap,\n\tfillMonthlyByMap,\n\tpad,\n\tannualAverage,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap\n};\n","// Source: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm\n// https://vsp.pnnl.gov/help/Vsample/Rosners_Outlier_Test.htm\n// https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm\n// https://www.math.ucla.edu/~tom/distributions/KolSmir2.html?\nimport { DataFrame } from \"data-forge\";\nimport {\n  sampleStandardDeviation,\n  mean as _mean,\n  max,\n  median as _median,\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nimport { Studentt } from \"distributions\";\nimport dayjs from \"dayjs\";\n\nfunction rval(df) {\n  let values = df.deflate(row => row.x).toArray();\n  let std = sampleStandardDeviation(values);\n  let mean = _mean(values);\n  if (std === 0) {\n    let ndf = df.generateSeries({ ares: row => 0 });\n    return { R: 0, std, mean, df: ndf };\n  }\n  let ndf = new DataFrame({\n    values: values.map(x => ({\n      x,\n      ares: Math.abs(x - mean) / std\n    }))\n  });\n  let R = max(ndf.deflate(row => row.ares).toArray());\n  return { R, df: ndf, std, mean };\n}\n\nfunction pValue(n, i, alpha) {\n  let p = 1 - alpha / (2 * (n - i + 1));\n  return p;\n}\nfunction tValue(p, degreeOfFreedom) {\n  let qt = new Studentt(degreeOfFreedom);\n  let t = qt.inv(p);\n  return t;\n}\n//\nfunction lambdaTest(n, i, alpha) {\n  let p = pValue(n, i, alpha);\n  let df = n - i - 1;\n  let t = tValue(p, df);\n  let lambda =\n    (t * (n - i)) /\n    Math.sqrt((n - i - 1 + Math.pow(t, 2)) * (n - i + 1));\n  return { lambda, p, t };\n}\nfunction rosnerTest(dataset = [], k = 10, alpha = 0.05) {\n  let dataframe = new DataFrame({\n    values: dataset.map(x => ({ x }))\n  });\n  let n = dataframe.getSeries(\"x\").count();\n  let newdf;\n  let i = 1;\n  let outliers = [];\n  let trip = false;\n  while (i <= k) {\n    let pair = {};\n    let s = Date.now();\n    if (i === 1) {\n      let { R, df, mean, std } = rval(dataframe);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    } else {\n      let { R, df, mean, std } = rval(newdf);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    }\n    let { lambda, p, t } = lambdaTest(n, i, alpha);\n    pair = Object.assign({}, pair, { lambda });\n    outliers.push(pair);\n    if (trip && pair.R > pair.lambda) trip = false;\n    if (pair.R === 0) break;\n    if (pair.R < pair.lambda) {\n      if (trip) {\n        break;\n      } else {\n        trip = true;\n      }\n    }\n    i++;\n  }\n  outliers = new DataFrame(outliers)\n    .generateSeries({\n      outlier: row => row.R > row.lambda\n    })\n    .takeWhile(row => row.outlier);\n  let outlierValues = outliers\n    .where(row => row.Value > 0)\n    .deflate(row => row.Value);\n  let thresholds = {\n    lower: 0,\n    upper:\n      outlierValues.count() > 0 ? outlierValues.min() : Infinity\n  };\n  return {\n    outliers,\n    thresholds,\n    iterations: i\n  };\n}\nconst modz = (value, mad, median) => {\n  return (0.6745 * (value - median)) / mad;\n};\nfunction modifiedZScoreTest(values) {\n  let median = _median(values);\n  let mad = medianAbsoluteDeviation(values);\n  values = values\n    .sort((a, b) => b - a)\n    .filter(v => v > 0)\n    .map(v => [v, modz(v, mad, median)]);\n  let outliers = values.filter(\n    ([v, modz]) => Math.abs(modz) >= 3.5\n  );\n  let upper = Math.min(\n    ...[Infinity, ...outliers.map(v => v[0])]\n  );\n  // let score,\n  // \tvalue,\n  // \tthreshold = Infinity,\n  // \tindex = 0;\n  // do {\n  // \tvalue = values[index];\n  // \tscore = modz(value, mad, median);\n  // \tif (Math.abs(score) >= 3.5) threshold = value;\n  // } while (score >= 3.5);\n  return { thresholds: { upper, lower: 0 } };\n}\nfunction boxPlotTest(values) {\n  let q1 = quantile(values, 0.25);\n  let q3 = quantile(values, 0.75);\n  let iqr = q3 - q1;\n  return {\n    thresholds: {\n      lowerInner: q1 - 1.5 * iqr,\n      upperInner: q1 - 3 * iqr,\n      lowerOuter: q3 + 1.5 * iqr,\n      upperOuter: q3 + 3 * iqr\n    }\n  };\n}\nfunction calculateOutlierThresholds(\n  df,\n  { k, filterZeros = true } = {}\n) {\n  let values = df\n    .where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        Array.isArray(row.flag)\n    )\n    .where(row => !isNaN(row.value) && row.value !== null)\n    .getSeries(\"value\")\n    .bake();\n  if (filterZeros) values = values.where(value => value > 0);\n  if (!k) {\n    k =\n      values.count() < 1000\n        ? Math.floor(values.count() * 0.15)\n        : Math.min(...[1000, Math.floor(values.count() * 0.02)]);\n  }\n  if (values.count < 5) return {};\n  let { outliers, threshold } = rosnerTest(values.toArray(), k);\n  return { outliers, threshold };\n}\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  zeroGroups.forEach(dff => {\n    dff = dff.transformSeries({\n      value: value => null,\n      flag: value => [\"zero\"]\n    });\n    df = DataFrame.merge([df, dff]);\n  });\n  return df;\n}\nfunction isOutlier(value, { lower, upper }) {\n  if (value < lower || value >= upper) {\n    return true;\n  }\n  return false;\n}\nfunction validMean(df) {\n  let values = df\n    .getSeries(\"value\")\n    .where(value => typeof value === \"number\");\n  return values.average();\n}\nfunction validMonthlyMeanMap(df) {\n  let dateComparison = row =>\n    dayjs(row.date)\n      .startOf(\"month\")\n      .month();\n\n  df = df\n    .where(row => typeof row.value === \"number\")\n    .groupBy(dateComparison)\n    .select(group => ({\n      month: new Date(group.first().date).getMonth(),\n      value: group.deflate(row => row.value).average()\n    }));\n  return new Map(\n    df.toArray().map(({ month, value }) => [month, value])\n  );\n}\n\nfunction quality(df) {\n  let count = df.getIndex().count();\n  let valid = df\n    .getSeries(\"flag\")\n    .where(\n      value =>\n        value === null ||\n        (Array.isArray(value) && value.length === 0)\n    )\n    .count();\n  let missing = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"missing\") !== -1)\n    .count();\n  let dirty = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"clean\") !== -1)\n    .count();\n  let zerod = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"zero\") !== -1)\n    .count();\n  let breakdown = {\n    valid: valid / count,\n    missing: missing / count,\n    invalid: (dirty + zerod) / count\n  };\n  let report = {\n    accuracy: (1 - dirty / count) * 4,\n    completeness: 4 * breakdown.valid,\n    consistency: 4 * ((count - missing - zerod) / count)\n  };\n  return { breakdown, report, count };\n}\n\nexport {\n  rosnerTest,\n  modifiedZScoreTest,\n  boxPlotTest,\n  calculateOutlierThresholds,\n  zeroReplacement,\n  isOutlier,\n  validMean,\n  validMonthlyMeanMap,\n  quality\n};\n","import dayjs from \"dayjs\";\nimport dataForge from \"data-forge\";\nimport { msToInterval, intervalToMS } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport has from \"lodash/has\";\nimport get from \"lodash/get\";\nimport fromPairs from \"lodash/fromPairs\";\nimport {\n\tgapExists,\n\tgapFill,\n\taverageMonthlyMap,\n\tfillMonthlyByMap,\n\tpad,\n\tannualAverage,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap\n} from \"./lib/Timeseries.fill\";\nimport {\n\tckmeans,\n\tmax,\n\tmedianAbsoluteDeviation,\n\tquantile\n} from \"simple-statistics\";\n\nimport {\n\trosnerTest,\n\tboxPlotTest,\n\tmodifiedZScoreTest\n} from \"./lib/Timeseries.statistics\";\nimport { annualScale, calculateChange } from \"./lib/misc\";\n\n// export default ;\n// Fill Options\nexport {\n\tTimeseries,\n\tannualAverage,\n\taverageMonthlyMap,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap,\n\tfillMonthlyByMap,\n\tpad\n};\nfunction Timeseries(data = [], options = {}) {\n\t// const { msIndex } = options;\n\tif (data instanceof Timeseries) {\n\t\treturn data;\n\t}\n\tif (data instanceof dataForge.DataFrame) {\n\t\tdata = data.toArray();\n\t}\n\n\tdata = data\n\t\t.map(({ date, ...others }) => ({ date: dayjs(date), ...others }))\n\t\t.sort((a, b) => a.date.valueOf() - b.date.valueOf());\n\tlet config = {\n\t\t// columns: ['date', 'value', 'raw', 'flag'],\n\t\tvalues: data,\n\t\tindex: data.map(({ date }) => date.toDate()),\n\t\tconsiderAllRows: true\n\t};\n\tdataForge.DataFrame.call(this, config);\n}\n\nTimeseries.prototype = Object.create(dataForge.DataFrame.prototype);\nTimeseries.prototype.constructor = Timeseries;\n\n// Getters\nfunction getValueColumns() {\n\treturn this.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray();\n}\nfunction interval() {\n\tconst computeInterval = window => window.last() - window.first();\n\tconst intervals = this.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => -row.Frequency);\n\t// .orderBy(row => row.Value);\n\n\tlet val = intervals.first().Value;\n\n\treturn msToInterval(val);\n}\n\nfunction dateRange(unit, adjustment) {\n\tlet start = dayjs(this.first().date),\n\t\tend = dayjs(this.last().date);\n\tif (adjustment) {\n\t\tstart = start.startOf(adjustment);\n\t\tend = end.endOf(adjustment);\n\t}\n\treturn end.diff(start, unit);\n}\nTimeseries.prototype.getValueColumns = getValueColumns;\nTimeseries.prototype.getInterval = interval;\nTimeseries.prototype.getDateRange = dateRange;\n\n// Statistics\nfunction cvrsme(actual, simulated) {\n\tlet df = this.subset([actual, simulated])\n\t\t.resetIndex()\n\t\t.generateSeries({\n\t\t\tactual: row => row[actual] || 0,\n\t\t\tsimulated: row => row[simulated] || 0\n\t\t})\n\t\t.dropSeries([actual, simulated])\n\t\t.generateSeries({ diff: row => row.actual - row.simulated });\n\tlet n = df.count();\n\tlet p = 1.0;\n\tlet ybar = df.getSeries(\"actual\").sum() / n;\n\tlet v = Math.sqrt(df.getSeries(\"diff\").sum() / (n - p)) / ybar;\n\treturn v;\n}\nfunction nmbe(actual, simulated) {\n\tlet df = this.subset([actual, simulated])\n\t\t.resetIndex()\n\t\t.generateSeries({\n\t\t\tactual: row => row[actual] || 0,\n\t\t\tsimulated: row => row[simulated] || 0\n\t\t})\n\t\t.dropSeries([actual, simulated])\n\t\t.generateSeries({ diff: row => row.actual - row.simulated });\n\n\tlet n = df.count();\n\tlet p = 1.0;\n\tlet ybar = df.getSeries(\"actual\").sum() / n;\n\tlet b = df.getSeries(\"diff\").sum() / ((n - p) * ybar);\n\treturn b;\n}\nTimeseries.prototype.cvrsme = cvrsme;\nTimeseries.prototype.nmbe = nmbe;\n\n// Formatting\nfunction toCSV() {\n\tlet df = this.transformSeries({\n\t\tdate: date => dayjs(date).toISOString()\n\t}).toCSV();\n\treturn df;\n}\nTimeseries.prototype.asCSV = toCSV;\n// Methods\nfunction calculateThresholdOptions({\n\tk,\n\tfilterZeros = true,\n\tfilterNegative = true\n} = {}) {\n\tlet noflags = this.where(\n\t\trow =>\n\t\t\trow.flag === null ||\n\t\t\trow.flag === undefined ||\n\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t)\n\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t.getSeries(\"value\");\n\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\tif (filterNegative) noflags = noflags.where(value => value > 0);\n\tif (!k) {\n\t\tk =\n\t\t\tnoflags.count() < 1000\n\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t}\n\tif (noflags.count() < 5) return {};\n\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\treturn { esd, box, modz };\n}\n\nfunction getBestThreshold() {\n\ttry {\n\t\tlet thresholds = this.calculateThresholdOptions();\n\t\tconst thresholdGroups = ckmeans(\n\t\t\t[\n\t\t\t\tget(thresholds, \"esd.upper\", null),\n\t\t\t\tget(thresholds, \"modz.upper\", null),\n\t\t\t\tget(thresholds, \"box.lowerOuter\", null),\n\t\t\t\tget(thresholds, \"box.upperOuter\", null)\n\t\t\t].filter(v => v),\n\t\t\t2\n\t\t);\n\t\tlet threshold_actual = max(\n\t\t\tthresholdGroups.reduce((a, b) => (a.length > b.length ? a : b))\n\t\t);\n\t\treturn threshold_actual;\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tthrow new Error(\"Cannot determine threshold\");\n\t}\n}\n\nfunction calculateStatistics(options = {}) {\n\tconst {\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = options;\n\tlet series = this.deflate(row => row[column]).where(value => !isNaN(value));\n\tif (filterNegative) series = series.where(value => value >= 0);\n\tif (filterZeros) series = series.where(value => value !== 0);\n\tlet median = series.median();\n\tlet mean = series.average();\n\tlet count = series.count();\n\tlet std = series.std();\n\tlet min = series.min();\n\tlet max = series.max();\n\tlet mad = medianAbsoluteDeviation(series.toArray());\n\tlet q1 = quantile(series.toArray(), 0.25);\n\tlet q3 = quantile(series.toArray(), 0.75);\n\tlet iqr = q3 - q1;\n\tlet stats = {\n\t\tmedian,\n\t\tmean,\n\t\tcount,\n\t\tstd,\n\t\tmin,\n\t\tmax,\n\t\tmad,\n\t\tq1,\n\t\tq3,\n\t\tiqr\n\t};\n\treturn stats;\n}\n\nTimeseries.prototype.calculateStatistics = calculateStatistics;\nTimeseries.prototype.calculateThresholdOptions = calculateThresholdOptions;\nTimeseries.prototype.getBestThreshold = getBestThreshold;\n\n// Chainable Methods\nfunction betweenDates(start, end) {\n\tstart = dayjs(start).toDate();\n\tend = dayjs(end).toDate();\n\tlet df = this.between(start, end);\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.betweenDates = betweenDates;\n\nfunction transformAllSeries(adjustmentFunction, { exclude }) {\n\tlet df = this;\n\tlet columns = (columns = df\n\t\t.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray());\n\tif (exclude && Array.isArray(exclude)) {\n\t\tcolumns = columns.filter(col => exclude.indexOf(col) === -1);\n\t}\n\tcolumns.forEach(col => {\n\t\tdf = df.transformSeries({\n\t\t\t[col]: value => {\n\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\treturn df;\n}\n\nTimeseries.prototype.transformAllSeries = transformAllSeries;\n\nfunction reset() {\n\tlet df = this.withSeries({\n\t\tvalue: row =>\n\t\t\trow.flag && Array.isArray(row.flag) && row.flag.length > 0\n\t\t\t\t? row.raw\n\t\t\t\t: row.value\n\t})\n\t\t.subset([\"date\", \"value\"])\n\t\t.where(row => !isNaN(row.value) && row.value !== null);\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.reset = reset;\n\n// To and From Totalizers\nfunction fromTotalizer(col = \"value\", { acceptInitial = false } = {}) {\n\tlet array = this.subset([\"date\", col])\n\t\t.toArray()\n\t\t.map((v, i, arr) => {\n\t\t\tlet val = acceptInitial ? v[col] : null;\n\t\t\tif (arr[i - 1]) {\n\t\t\t\tval = v[col] - arr[i - 1][col];\n\t\t\t}\n\t\t\treturn { date: v.date, [col]: val };\n\t\t});\n\tlet ndf = new Timeseries(a);\n\treturn ndf;\n}\nfunction toTotalizer(col, { adjustInitial } = {}) {\n\tlet array = this.subset([\"date\", col])\n\t\t.toArray()\n\t\t.map((v, i, arr) => {\n\t\t\tlet val = arr\n\t\t\t\t.slice(0, i)\n\t\t\t\t.map(obj => obj[col])\n\t\t\t\t.reduce((a, b) => a + b, 0);\n\t\t\treturn { date: v.date, [col]: val };\n\t\t});\n\tlet ndf = new Timeseries(a);\n\treturn ndf;\n}\nTimeseries.prototype.fromTotalizer = fromTotalizer;\nTimeseries.prototype.toTotalizer = toTotalizer;\n\nfunction group(interval, toArray) {\n\tif ([\"hour\", \"day\", \"week\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\tlet groups = this.groupBy(dateComparison);\n\treturn groups;\n}\n\nTimeseries.prototype.group = group;\n\nfunction removeOutliers({ series = \"value\", lower, upper } = {}) {\n\tif (lower > upper) throw new Error(\"thresholds invalid\");\n\tlet outlierCheck = (value, lower, upper) => value < lower || value > upper;\n\n\tlet outliers = this.where(row => outlierCheck(row[series], lower, upper))\n\t\t.generateSeries({\n\t\t\traw: row => row[series],\n\t\t\tflag: ({ flag = [] }) => [\"outlier\", ...flag]\n\t\t})\n\t\t.transformSeries({\n\t\t\t[series]: value => null\n\t\t});\n\n\tlet merged = this.merge(outliers);\n\treturn new Timeseries(merged);\n}\n\nTimeseries.prototype.removeOutliers = removeOutliers;\nTimeseries.prototype.clean = removeOutliers;\n\nfunction downsample([duration, value], fillType = \"sum\") {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t}\n\tlet dateComparison = row => row.date.startOf(duration);\n\tlet valueColumns = this.getValueColumns();\n\tif (value) {\n\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t}\n\tlet df = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\t...fromPairs([\n\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t}),\n\t\t\t\t\t...group\n\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => dayjs(row.date).toDate());\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.downsample = downsample;\nfunction downsampleClean([duration, value], threshold = 0.8) {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tlet dateComparison = row => row.date.startOf(duration);\n\tlet valueColumns = this.getValueColumns();\n\tif (value) {\n\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t}\n\tlet df = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\tlet quality = new Timeseries(group).dataQuality().setIndex(\"flag\");\n\t\t\tlet clean = quality.at(\"clean\").percent;\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\tvalue:\n\t\t\t\t\tclean >= threshold\n\t\t\t\t\t\t? group\n\t\t\t\t\t\t\t\t.deflate(row => row.value)\n\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t.sum()\n\t\t\t\t\t\t: null\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => dayjs(row.date).toDate());\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.downsampleClean = downsampleClean;\nfunction upsample([duration, value], fillType = \"average\", flag = false) {\n\t// Dont use this b/c it has the raw and flag values\n\tlet df = this;\n\n\t// let blank = Timeseries.blank(df.first().date, df.last().date, [\n\t// \tduration,\n\t// \tvalue\n\t// ]);\n\t// let n = Timeseries.merge([blank, df]).fillNull();\n\n\tlet n = df.fillGaps(\n\t\tgapExists([duration, value]),\n\t\tgapFill(fillType, [duration, value])\n\t);\n\tif (!flag) n = n.dropSeries([\"flag\"]);\n\treturn new Timeseries(n);\n}\n\nTimeseries.prototype.upsample = upsample;\n\nfunction populate(value, type = \"average\") {\n\tlet v;\n\tswitch (type) {\n\t\tcase \"fill\":\n\t\t\tv = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = value / this.count();\n\t\t\tbreak;\n\t}\n\tlet df = this.generateSeries({ value: row => v });\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.populate = populate;\n\nfunction reduceToValue(columnNames) {\n\tfunction chooseValue(row, columnNames = []) {\n\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\treturn values[0] || 0;\n\t}\n\tlet df = this.generateSeries({\n\t\tvalue: row => chooseValue(row, columnNames)\n\t}).subset([\"date\", \"value\"]);\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.reduceToValue = reduceToValue;\n\nfunction cumulativeSum(columns) {\n\tif (!columns) columns = this.getValueColumns();\n\tif (columns & !Array.isArray(columns)) columns = [columns];\n\tlet df = this;\n\tconst cumulativeSum = sum => value => (sum += value);\n\tcolumns.forEach(s => {\n\t\tdf = df.withSeries(s, df.getSeries(s).select(cumulativeSum(0)));\n\t});\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.cumulativeSum = cumulativeSum;\n\nfunction totalRows(series = [\"value\"], colname = \"total\") {\n\tlet ndf = this.generateSeries({\n\t\t[colname]: row => series.map(v => row[v] || 0).reduce((a, b) => a + b, 0)\n\t});\n\treturn new Timeseries(ndf);\n}\nTimeseries.prototype.totalRows = totalRows;\nTimeseries.prototype.totalRow = totalRows;\nTimeseries.prototype.totalColumns = totalRows;\n\n// Baseline Functions\nfunction rollingPercentChange(col = \"value\", decimal = true) {\n\tlet df = this;\n\tlet s = df\n\t\t.getSeries(col)\n\t\t.rollingWindow(2)\n\t\t.select(window => {\n\t\t\tlet v = (window.last() - window.first()) / Math.abs(window.first());\n\t\t\treturn [window.getIndex().last(), v];\n\t\t})\n\t\t.withIndex(pair => pair[0])\n\t\t.select(pair => pair[1]);\n\tlet delta = df.withSeries(\"delta\", s);\n\tif (!decimal) delta = delta.transformSeries({ delta: value => value * 100 });\n\treturn new Timeseries(delta);\n}\n\nTimeseries.prototype.rollingPercentChange = rollingPercentChange;\nfunction baselinePercentChange(baselineDF) {\n\t// Only Change in Year\n\tif (!(baselineDF instanceof Timeseries))\n\t\tbaselineDF = new Timeseries(baselineDF);\n\tlet dfwb;\n\tif (baselineDF.count() > 1) {\n\t\tlet interval = this.getInterval();\n\t\tlet baselineInterval = baselineDF.interval;\n\t\tif (!isEqual(interval, baselineInterval)) {\n\t\t\tconsole.error(interval, baselineInterval);\n\t\t\tthrow new Error(\"baseline and data intervals do not match\");\n\t\t}\n\t\tlet indexer;\n\t\tswitch (interval[0]) {\n\t\t\tcase \"day\":\n\t\t\t\tindexer = date => `${date.month()}-${date.date()}`;\n\t\t\t\tbreak;\n\t\t\tcase \"month\":\n\t\t\t\tindexer = date => date.month();\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tindexer = date => 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet indexedBaseline = baselineDF.withIndex(row => indexer(row.date));\n\t\tlet getBaselineValue = index => {\n\t\t\tlet at = indexedBaseline.at(index);\n\t\t\tif (at && has(at, \"value\")) {\n\t\t\t\treturn at.value;\n\t\t\t} else {\n\t\t\t\treturn indexedBaseline.getSeries(\"value\").average();\n\t\t\t}\n\t\t};\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => getBaselineValue(indexer(row.date))\n\t\t});\n\t} else {\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => baselineDF.first().value\n\t\t});\n\t}\n\tdfwb = dfwb.generateSeries({\n\t\tdelta: row => calculateChange(row.baseline, row.value)\n\t});\n\treturn new Timeseries(dfwb);\n}\n\nTimeseries.prototype.baselinePercentChange = baselinePercentChange;\nTimeseries.prototype.addBaselineDelta = baselinePercentChange;\n\nfunction annualIntensity(normalizeValue = 1) {\n\tlet interval = this.getInterval();\n\tlet annual = this.groupBy(row => row.date.year())\n\t\t.select(group => {\n\t\t\tlet startDate = group.first().date;\n\t\t\tlet endDate = group\n\t\t\t\t.last()\n\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\treturn {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\t...fromPairs(\n\t\t\t\t\tthis.getValueColumns().map(col => [\n\t\t\t\t\t\tcol,\n\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.renameSeries({ startDate: \"date\" })\n\t\t.dropSeries(\"endDate\");\n\treturn new Timeseries(annual);\n}\n\nTimeseries.prototype.annualIntensity = annualIntensity;\n\n// Fill Functions\n\nfunction fillMissing() {\n\tlet df = this;\n\tlet startDate = df.first().date.toDate(),\n\t\tendDate = df.last().date.toDate();\n\tlet interval = df.getInterval();\n\tlet bdf = Timeseries.blank(\n\t\tstartDate,\n\t\tendDate,\n\t\tinterval,\n\t\t\"missing\"\n\t).withIndex(row => row.date.valueOf());\n\tlet m = bdf.merge(df.withIndex(row => row.date.valueOf())).generateSeries({\n\t\tflag: row =>\n\t\t\trow.value === null || row.value === undefined ? row.flag : undefined\n\t});\n\tm = new Timeseries(m);\n\treturn m;\n}\nTimeseries.prototype.fillMissing = fillMissing;\n\nfunction fillNull({ series = \"value\", value, callback }) {\n\tconst seriesCheck = row => row[series] === null || row[series] === undefined;\n\tif (callback) {\n\t\tlet df = this.generateSeries({\n\t\t\tflag: row =>\n\t\t\t\tseriesCheck(row) ? [\"fill\", ...(row.flag || [])] : row.flag,\n\t\t\t[series]: row => (seriesCheck(row) ? callback(row) : row[series])\n\t\t});\n\t\treturn new Timeseries(df);\n\t} else if (value) {\n\t\tlet df = this.generateSeries({\n\t\t\tflag: row => (seriesCheck(row) ? [\"fill\", ...(row.flag || [])] : row.flag)\n\t\t}).transformSeries({\n\t\t\t[series]: currentValue =>\n\t\t\t\tcurrentValue === null || currentValue === undefined\n\t\t\t\t\t? value\n\t\t\t\t\t: currentValue\n\t\t});\n\t\treturn new Timeseries(df);\n\t} else {\n\t\treturn this;\n\t}\n}\nTimeseries.prototype.fillNull = fillNull;\n\nfunction zeroFaultDetection(thresholdInterval) {\n\tif (!Array.isArray(thresholdInterval))\n\t\tthresholdInterval = [thresholdInterval, 1];\n\tthresholdInterval = intervalToMS(thresholdInterval);\n\tlet df = this;\n\tlet zeroFaultDates = df\n\t\t.where(row => row.value === 0)\n\t\t.ensureSeries(\n\t\t\t\"interval\",\n\t\t\tdf\n\t\t\t\t.where(row => row.value === 0)\n\t\t\t\t.getSeries(\"date\")\n\t\t\t\t.amountChange()\n\t\t)\n\t\t.where(v => v.interval <= thresholdInterval)\n\t\t.subset([\"date\"])\n\t\t.generateSeries({ value: row => null, flag: row => [\"zeroFault\"] });\n\n\tlet zeroFaultDF = new Timeseries(this.merge(zeroFaultDates));\n\treturn zeroFaultDF;\n}\n\nTimeseries.prototype.zeroFaultDetection = zeroFaultDetection;\n\nfunction dataQuality() {\n\tlet count = this.count();\n\tlet withFlags = this.where(r => Array.isArray(r.flag) && r.flag.length > 0)\n\t\t.groupBy(r => r.flag.toString())\n\t\t.select(group => ({\n\t\t\tflag: group.first().flag,\n\t\t\tcount: group.count(),\n\t\t\tpercent: group.count() / count\n\t\t}))\n\t\t.inflate();\n\tlet good = this.where(\n\t\tr =>\n\t\t\tr.flag === undefined ||\n\t\t\tr.flag === null ||\n\t\t\t(Array.isArray(r.flag) && r.flag.length === 0)\n\t).count();\n\tlet quality = withFlags\n\t\t.appendPair([\n\t\t\twithFlags.count(),\n\t\t\t{ flag: \"clean\", count: good, percent: good / count }\n\t\t])\n\t\t.orderByDescending(row => row.count);\n\treturn quality;\n}\n\nTimeseries.prototype.dataQuality = dataQuality;\n\nfunction monthlyWithQual() {\n\tlet interval = this.getInterval();\n\tlet ms = intervalToMS(interval);\n\tconst duration = \"month\";\n\tlet dateComparison = row =>\n\t\tdayjs(row.date)\n\t\t\t.startOf()\n\t\t\t.valueOf();\n\tlet ts = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t.startOf(duration)\n\t\t\t\t.toDate();\n\t\t\tlet fullCount = Math.floor(\n\t\t\t\tdayjs(date)\n\t\t\t\t\t.endOf(\"month\")\n\t\t\t\t\t.diff(dayjs(date), \"millisecond\") / ms\n\t\t\t);\n\t\t\tlet days = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n\t\t\tlet count = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => v && v !== 0)\n\t\t\t\t.toArray().length;\n\t\t\tlet value = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => !isNaN(v))\n\t\t\t\t.sum();\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\tvalue: isNaN(value) ? 0 : value,\n\t\t\t\tcount,\n\t\t\t\tfullCount,\n\t\t\t\tscore: count / fullCount\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => row.date.toDate());\n\treturn new Timeseries(ts);\n}\nTimeseries.prototype.monthlyWithQual = monthlyWithQual;\n\nfunction threeYearAverage(date, series = \"value\", defaultValue) {\n\tdate = dayjs(date);\n\tif (!defaultValue)\n\t\tdefaultValue = this.getSeries(series)\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\n\t// let months = df\n\t// \t.before(date.valueOf())\n\t// \t.where(row => dayjs(row.date).month() === date.month())\n\t// \t.where(row => row.score > 0.9)\n\t// \t.tail(3);\n\tlet months = this.before(date.toDate())\n\t\t.where(row => row.date.month() === date.month())\n\t\t.orderBy(row => dayjs(row.date))\n\t\t.tail(3);\n\t// .where(row => row.score > 0.9);\n\tif (months.count() > 0) {\n\t\tlet val = months\n\t\t\t.getSeries(series)\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\t\treturn val;\n\t} else {\n\t\treturn defaultValue;\n\t}\n}\nTimeseries.prototype.threeYearAverage = threeYearAverage;\n\nfunction averageFill() {\n\tlet df = this;\n\tlet avg = df\n\t\t// .where(row => row.score ?row.score >= 0.9)\n\t\t.getSeries(\"value\")\n\t\t.where(v => !isNaN(v) && v !== null)\n\t\t.average();\n\tlet monthlyAvg = df\n\t\t.generateSeries({\n\t\t\trollingAverage: row => df.threeYearAverage(row.date, \"value\", avg)\n\t\t})\n\t\t.generateSeries({\n\t\t\tflag: row => (row.value ? row.flag : [\"filled\", ...(row.flag || [])])\n\t\t})\n\t\t.generateSeries({\n\t\t\tvalue: row => (row.value ? row.value : row.rollingAverage)\n\t\t})\n\t\t.dropSeries([\"rollingAverage\"]);\n\treturn new Timeseries(monthlyAvg);\n}\n\nTimeseries.prototype.averageFill = averageFill;\nfunction toArray() {\n\tconst values = [];\n\tfor (const value of this.getContent().values) {\n\t\tif (value !== undefined) {\n\t\t\tvalues.push(value);\n\t\t}\n\t}\n\treturn values.map(({ date, ...others }) => ({\n\t\tdate: date.toDate(),\n\t\t...others\n\t}));\n}\nTimeseries.prototype.toArray = toArray;\n\nfunction atDate(date) {\n\tif (this.none()) {\n\t\treturn undefined;\n\t}\n\tdate = dayjs(date).valueOf();\n\n\tfor (const pair of this.getContent().pairs) {\n\t\tif (pair[0].valueOf() === date) {\n\t\t\treturn pair[1];\n\t\t}\n\t}\n\treturn undefined;\n}\nTimeseries.prototype.atDate = atDate;\n\n// Static Methods\nfunction blank(startDate, endDate, [duration, value = 1], flag) {\n\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\tconsole.error(interval);\n\t\tthrow new Error(\"interval type not supported\");\n\t}\n\tstartDate = dayjs(startDate);\n\tendDate = dayjs(endDate);\n\tlet dates = [startDate];\n\tlet interval = intervalToMS([duration, value]);\n\twhile (dates[dates.length - 1].valueOf() < endDate.valueOf()) {\n\t\tdates.push(dayjs(dates[dates.length - 1]).add(value, duration));\n\t}\n\tlet df = new Timeseries(dates.map(date => ({ date })));\n\n\tif (flag) {\n\t\tdf = new Timeseries(\n\t\t\tdf.generateSeries({\n\t\t\t\tflag: row => [flag]\n\t\t\t})\n\t\t);\n\t}\n\n\treturn df;\n}\nTimeseries.blank = blank;\nfunction aggregate(dataframes) {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df));\n\tconst valueColumns = new Set(\n\t\tdataframes.map(df => df.getValueColumns()).reduce((a, b) => a.concat(b), [])\n\t);\n\tconst concatenated = dataForge.DataFrame.concat(dataframes)\n\t\t.groupBy(row => row.date)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date;\n\t\t\tlet o = { date };\n\t\t\tvalueColumns.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\tgroup\n\t\t\t\t.getColumnNames()\n\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t.filter(col => valueColumns.has(col) === -1)\n\t\t\t\t.forEach(col => {\n\t\t\t\t\tlet value = group\n\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t.toArray();\n\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\to[col] = value;\n\t\t\t\t\treturn;\n\t\t\t\t});\n\t\t\treturn o;\n\t\t})\n\t\t.inflate();\n\treturn new Timeseries(concatenated);\n}\n\nTimeseries.aggregate = aggregate;\nTimeseries.concat = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df =>\n\t\tnew Timeseries(df).withIndex(row => row.date.valueOf())\n\t);\n\tlet df = dataForge.DataFrame.concat(dataframes);\n\treturn new Timeseries(df);\n};\nTimeseries.merge = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df =>\n\t\tnew Timeseries(df).withIndex(row => row.date.valueOf())\n\t);\n\tlet df = dataForge.DataFrame.merge(dataframes);\n\treturn new Timeseries(df);\n};\n","import dayjs from \"dayjs\";\nexport const annualScale = (start, end) =>\n\t365 / dayjs(end).diff(dayjs(start), \"day\");\nexport const calculateChange = (baseline, value) =>\n\t(value - baseline) / baseline;\n"],"names":["intervalToMS","unit","value","start","dayjs","add","diff","valueFiller","fillType","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","val","nv","averageMonthlyMap","df","data","group","select","month","first","getSeries","where","v","average","m","Map","toArray","avg","set","annualMonthlyAverageMap","groupBy","row","year","startOf","ts","Timeseries","downsample","monthlyRollingAverageMap","years","series","aggregator","validOnly","months","toDate","Boolean","inflate","withIndex","bake","values","rollingWindow","window","last","has","forEach","before","count","fillMonthlyByMap","monthMap","get","fillMonthlyBAnnualyMap","annualMonthlyMap","mean","reduce","a","b","concat","pad","annualAverage","subset","after","subtract","r","hour","minute","appendPair","rval","deflate","x","std","sampleStandardDeviation","_mean","ndf","generateSeries","ares","R","DataFrame","Math","abs","max","lambdaTest","n","i","alpha","p","pValue","t","degreeOfFreedom","Studentt","inv","tValue","lambda","sqrt","pow","modz","mad","median","modifiedZScoreTest","_median","medianAbsoluteDeviation","outliers","sort","filter","thresholds","upper","min","Infinity","lower","options","dataForge","config","others","valueOf","index","considerAllRows","call","this","removeOutliers","outlierCheck","raw","transformSeries","[object Object]","merge","totalRows","colname","baselinePercentChange","baselineDF","dfwb","indexer","interval","getInterval","baselineInterval","isEqual","console","error","indexedBaseline","getBaselineValue","at","baseline","delta","calculateChange","prototype","Object","create","constructor","getValueColumns","detectTypes","Type","distinct","Column","ms","end","ceil","msToInterval","getIndex","detectValues","orderBy","Frequency","Value","getDateRange","adjustment","endOf","cvrsme","actual","simulated","resetIndex","dropSeries","ybar","sum","nmbe","asCSV","toISOString","toCSV","calculateStatistics","column","filterZeros","filterNegative","isNaN","q1","quantile","q3","iqr","calculateThresholdOptions","k","noflags","Array","isArray","length","floor","esd","dataset","newdf","dataframe","trip","pair","assign","push","outlier","takeWhile","outlierValues","iterations","rosnerTest","box","lowerInner","upperInner","lowerOuter","upperOuter","boxPlotTest","getBestThreshold","thresholdGroups","ckmeans","betweenDates","between","transformAllSeries","adjustmentFunction","exclude","columns","col","reset","withSeries","fromTotalizer","acceptInitial","arr","toTotalizer","slice","obj","clean","duration","dateComparison","valueColumns","getColumnNames","downsampleClean","threshold","dataQuality","setIndex","percent","upsample","fillGaps","durationValue","pairA","pairB","startDate","gapExists","endDate","newEntries","e","gapFill","populate","type","reduceToValue","columnNames","chooseValue","cumulativeSum","s","totalRow","totalColumns","rollingPercentChange","decimal","addBaselineDelta","annualIntensity","normalizeValue","scaler","renameSeries","fillMissing","blank","undefined","fillNull","callback","seriesCheck","currentValue","zeroFaultDetection","thresholdInterval","zeroFaultDates","ensureSeries","amountChange","withFlags","toString","good","orderByDescending","monthlyWithQual","fullCount","Date","getFullYear","getMonth","getDate","score","threeYearAverage","defaultValue","tail","averageFill","rollingAverage","getContent","atDate","none","pairs","dates","aggregate","dataframes","Set","o","c"],"mappings":"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"}
{"version":3,"file":"index.modern.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/lib/Timeseries.statistics.js","../src/index.js","../src/lib/misc.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\nconst intervalToMS = ([unit, value]) => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(value, unit);\n\treturn end.diff(start);\n};\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, intervalToMS, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration, true) / durationValue\n\t);\n\n\tif (gapSize > 0) return true;\n\treturn false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize;\n\tif (interval === \"quarterHour\") {\n\t\tgapSize = Math.floor(dayjs(endDate).diff(startDate, \"minutes\") / 15);\n\t} else {\n\t\tgapSize = dayjs(endDate).diff(startDate, interval);\n\t}\n\tif (maxGap && maxGap > gapSize) return false;\n\tif (gapSize > 0) return true;\n\treturn false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst newEntries = [];\n\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet date = dayjs(startDate).add((entryIndex + 1) * durationValue, duration);\n\t\tnewEntries.push([\n\t\t\tdate.valueOf(),\n\t\t\t{ date, value: undefined, ...(flag && { flag: [flag] }) }\n\t\t]);\n\t}\n\treturn newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n\tfillType,\n\t{ startValue, endValue, entryIndex, numEntries },\n\t{ overrideValue, dateFunction, date, flag }\n) => {\n\tif (\n\t\t[\"pad\", \"interpolate\", \"average\", \"dateFunction\", \"value\"].indexOf(\n\t\t\tfillType\n\t\t) === -1\n\t) {\n\t\tthrow new Error(\"fill Type not supported\");\n\t}\n\tlet value;\n\tif (fillType === \"pad\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, startValue[key]];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", \"pad\"];\n\t} else if (fillType === \"interpolate\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv =\n\t\t\t\t\tstartValue[key] +\n\t\t\t\t\t(entryIndex + 1) *\n\t\t\t\t\t\t((endValue[key] - startValue[key]) / (numEntries + 1));\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"average\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = (startValue[key] + endValue[key]) / numEntries;\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"dateFunction\" && dateFunction) {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = dateFunction(date);\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"value\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv;\n\t\t\t\tif (typeof overrideValue === \"number\") {\n\t\t\t\t\tnv = overrideValue;\n\t\t\t\t} else {\n\t\t\t\t\tnv = overrideValue[key];\n\t\t\t\t}\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, null];\n\t\t\t})\n\t\t);\n\t\tflag = [\"fill\"];\n\t}\n\treturn { ...value, flag };\n};\n\nconst gapFill = (\n\tfillType,\n\t[duration, durationValue],\n\t{ overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n\t// Fill values forward.\n\n\tconst startDate = dayjs(pairA[0]);\n\tconst endDate = dayjs(pairB[0]);\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst startValue = pairA[1];\n\tconst endValue = pairB[1];\n\tconst newEntries = [];\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet adjustment = valueFiller(\n\t\t\t\tfillType,\n\t\t\t\t{ startValue, endValue, entryIndex, numEntries },\n\t\t\t\t{\n\t\t\t\t\toverrideValue,\n\t\t\t\t\tdateFunction,\n\t\t\t\t\tflag\n\t\t\t\t}\n\t\t\t),\n\t\t\tdate = dayjs(startDate)\n\t\t\t\t.add((entryIndex + 1) * durationValue, duration)\n\t\t\t\t.toDate();\n\t\tlet e = [date.valueOf(), Object.assign({}, adjustment, { date })];\n\t\tnewEntries.push(e);\n\t}\n\n\treturn newEntries;\n};\n\nexport { gapExists, gapFill, gapFillBlank, gapFillNull, valueFiller };\n","// Source: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm\n// https://vsp.pnnl.gov/help/Vsample/Rosners_Outlier_Test.htm\n// https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm\n// https://www.math.ucla.edu/~tom/distributions/KolSmir2.html?\nimport { DataFrame } from \"data-forge\";\nimport {\n  sampleStandardDeviation,\n  mean as _mean,\n  max,\n  median as _median,\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nimport { Studentt } from \"distributions\";\nimport dayjs from \"dayjs\";\nfunction rval(df) {\n  let values = df.deflate(row => row.x).toArray();\n  let std = sampleStandardDeviation(values);\n  let mean = _mean(values);\n  if (std === 0) {\n    let ndf = df.generateSeries({ ares: row => 0 });\n    return { R: 0, std, mean, df: ndf };\n  }\n  let ndf = new DataFrame({\n    values: values.map(x => ({\n      x,\n      ares: Math.abs(x - mean) / std\n    }))\n  });\n  let R = max(ndf.deflate(row => row.ares).toArray());\n  return { R, df: ndf, std, mean };\n}\n\nfunction pValue(n, i, alpha) {\n  let p = 1 - alpha / (2 * (n - i + 1));\n  return p;\n}\nfunction tValue(p, degreeOfFreedom) {\n  let qt = new Studentt(degreeOfFreedom);\n  let t = qt.inv(p);\n  return t;\n}\n//\nfunction lambdaTest(n, i, alpha) {\n  let p = pValue(n, i, alpha);\n  let df = n - i - 1;\n  let t = tValue(p, df);\n  let lambda =\n    (t * (n - i)) /\n    Math.sqrt((n - i - 1 + Math.pow(t, 2)) * (n - i + 1));\n  return { lambda, p, t };\n}\nfunction rosnerTest(dataset = [], k = 10, alpha = 0.05) {\n  let dataframe = new DataFrame({\n    values: dataset.map(x => ({ x }))\n  });\n  let n = dataframe.getSeries(\"x\").count();\n  let newdf;\n  let i = 1;\n  let outliers = [];\n  let trip = false;\n  while (i <= k) {\n    let pair = {};\n    let s = Date.now();\n    if (i === 1) {\n      let { R, df, mean, std } = rval(dataframe);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    } else {\n      let { R, df, mean, std } = rval(newdf);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    }\n    let { lambda, p, t } = lambdaTest(n, i, alpha);\n    pair = Object.assign({}, pair, { lambda });\n    outliers.push(pair);\n    if (trip && pair.R > pair.lambda) trip = false;\n    if (pair.R === 0) break;\n    if (pair.R < pair.lambda) {\n      if (trip) {\n        break;\n      } else {\n        trip = true;\n      }\n    }\n    i++;\n  }\n  outliers = new DataFrame(outliers)\n    .generateSeries({\n      outlier: row => row.R > row.lambda\n    })\n    .takeWhile(row => row.outlier);\n  let outlierValues = outliers\n    .where(row => row.Value > 0)\n    .deflate(row => row.Value);\n  let thresholds = {\n    lower: 0,\n    upper:\n      outlierValues.count() > 0 ? outlierValues.min() : Infinity\n  };\n  return {\n    outliers,\n    thresholds,\n    iterations: i\n  };\n}\nconst modz = (value, mad, median) => {\n  return (0.6745 * (value - median)) / mad;\n};\nfunction modifiedZScoreTest(values) {\n  let median = _median(values);\n  let mad = medianAbsoluteDeviation(values);\n  values = values\n    .sort((a, b) => b - a)\n    .filter(v => v > 0)\n    .map(v => [v, modz(v, mad, median)]);\n  let outliers = values.filter(\n    ([v, modz]) => Math.abs(modz) >= 3.5\n  );\n  let upper = Math.min(\n    ...[Infinity, ...outliers.map(v => v[0])]\n  );\n  // let score,\n  // \tvalue,\n  // \tthreshold = Infinity,\n  // \tindex = 0;\n  // do {\n  // \tvalue = values[index];\n  // \tscore = modz(value, mad, median);\n  // \tif (Math.abs(score) >= 3.5) threshold = value;\n  // } while (score >= 3.5);\n  return { thresholds: { upper, lower: 0 } };\n}\nfunction boxPlotTest(values) {\n  let q1 = quantile(values, 0.25);\n  let q3 = quantile(values, 0.75);\n  let iqr = q3 - q1;\n  return {\n    thresholds: {\n      lowerInner: q1 - 1.5 * iqr,\n      upperInner: q1 - 3 * iqr,\n      lowerOuter: q3 + 1.5 * iqr,\n      upperOuter: q3 + 3 * iqr\n    }\n  };\n}\nfunction calculateOutlierThresholds(\n  df,\n  { k, filterZeros = true } = {}\n) {\n  let values = df\n    .where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        Array.isArray(row.flag)\n    )\n    .where(row => !isNaN(row.value) && row.value !== null)\n    .getSeries(\"value\")\n    .bake();\n  if (filterZeros) values = values.where(value => value > 0);\n  if (!k) {\n    k =\n      values.count() < 1000\n        ? Math.floor(values.count() * 0.15)\n        : Math.min(...[1000, Math.floor(values.count() * 0.02)]);\n  }\n  if (values.count < 5) return {};\n  let { outliers, threshold } = rosnerTest(values.toArray(), k);\n  return { outliers, threshold };\n}\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  zeroGroups.forEach(dff => {\n    dff = dff.transformSeries({\n      value: value => null,\n      flag: value => [\"zero\"]\n    });\n    df = DataFrame.merge([df, dff]);\n  });\n  return df;\n}\nfunction isOutlier(value, { lower, upper }) {\n  if (value < lower || value >= upper) {\n    return true;\n  }\n  return false;\n}\nfunction validMean(df) {\n  let values = df\n    .getSeries(\"value\")\n    .where(value => typeof value === \"number\");\n  return values.average();\n}\nfunction validMonthlyMeanMap(df) {\n  let dateComparison = row =>\n    dayjs(row.date)\n      .startOf(\"month\")\n      .month();\n\n  df = df\n    .where(row => typeof row.value === \"number\")\n    .groupBy(dateComparison)\n    .select(group => ({\n      month: new Date(group.first().date).getMonth(),\n      value: group.deflate(row => row.value).average()\n    }));\n  return new Map(\n    df.toArray().map(({ month, value }) => [month, value])\n  );\n}\n\nfunction quality(df) {\n  let count = df.getIndex().count();\n  let valid = df\n    .getSeries(\"flag\")\n    .where(\n      value =>\n        value === null ||\n        (Array.isArray(value) && value.length === 0)\n    )\n    .count();\n  let missing = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"missing\") !== -1)\n    .count();\n  let dirty = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"clean\") !== -1)\n    .count();\n  let zerod = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"zero\") !== -1)\n    .count();\n  let breakdown = {\n    valid: valid / count,\n    missing: missing / count,\n    invalid: (dirty + zerod) / count\n  };\n  let report = {\n    accuracy: (1 - dirty / count) * 4,\n    completeness: 4 * breakdown.valid,\n    consistency: 4 * ((count - missing - zerod) / count)\n  };\n  return { breakdown, report, count };\n}\n\nexport {\n  rosnerTest,\n  modifiedZScoreTest,\n  boxPlotTest,\n  calculateOutlierThresholds,\n  zeroReplacement,\n  isOutlier,\n  validMean,\n  validMonthlyMeanMap,\n  quality\n};\n","import dayjs from \"dayjs\";\nimport dataForge from \"data-forge\";\nimport { msToInterval, intervalToMS } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport has from \"lodash/has\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\nimport {\n\trosnerTest,\n\tboxPlotTest,\n\tmodifiedZScoreTest\n} from \"./lib/Timeseries.statistics\";\nimport { annualScale, calculateChange } from \"./lib/misc\";\n\nconst Timeseries = dataForge.DataFrame;\n\nfunction setDateIndex(col = \"date\") {\n\tif (this.getColumnNames().indexOf(col) === -1)\n\t\tthrow new Error(\"No Date Column in DataFrame\");\n\treturn this.orderBy(row => row[col].valueOf()).withIndex(row =>\n\t\tdayjs(row.date).toDate()\n\t);\n}\nfunction interval() {\n\tconst computeInterval = window => window.last() - window.first();\n\n\tconst intervals = this.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => -row.Frequency)\n\t\t.orderBy(row => row.Value);\n\tlet val = intervals.first().Value;\n\treturn msToInterval(val);\n}\n\nfunction getValueColumns() {\n\treturn this.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray();\n}\n\nfunction dateRange(unit, adjustment) {\n\tlet start = dayjs(this.first().date),\n\t\tend = dayjs(this.last().date);\n\tif (adjustment) {\n\t\tstart = start.startOf(adjustment);\n\t\tend = end.endOf(adjustment);\n\t}\n\treturn end.diff(start, unit);\n}\n\nfunction calculateThresholdOptions({\n\tk,\n\tfilterZeros = true,\n\tfilterNegative = true\n} = {}) {\n\tlet noflags = this.where(\n\t\trow =>\n\t\t\trow.flag === null ||\n\t\t\trow.flag === undefined ||\n\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t)\n\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t.getSeries(\"value\");\n\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\tif (filterNegative) noflags = noflags.where(value => value > 0);\n\tif (!k) {\n\t\tk =\n\t\t\tnoflags.count() < 1000\n\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t}\n\tif (noflags.count() < 5) return {};\n\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\treturn { esd, box, modz };\n}\nfunction claculateStatistics(options = {}) {\n\tconst {\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = options;\n\tlet series = this.deflate(row => row[column]).where(value => !isNaN(value));\n\tif (filterNegative) series = series.where(value => value >= 0);\n\tif (filterZeros) series = series.where(value => value !== 0);\n\tlet median = series.median();\n\tlet mean = series.average();\n\tlet count = series.count();\n\tlet std = series.std();\n\tlet min = series.min();\n\tlet max = series.max();\n\tlet mad = medianAbsoluteDeviation(series.toArray());\n\tlet q1 = quantile(series.toArray(), 0.25);\n\tlet q3 = quantile(series.toArray(), 0.75);\n\tlet iqr = q3 - q1;\n\tlet stats = {\n\t\tmedian,\n\t\tmean,\n\t\tcount,\n\t\tstd,\n\t\tmin,\n\t\tmax,\n\t\tmad,\n\t\tq1,\n\t\tq3,\n\t\tiqr\n\t};\n\treturn stats;\n}\nfunction transformAllSeries(adjustmentFunction, { exclude }) {\n\tlet df = this;\n\tlet columns = (columns = df\n\t\t.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray());\n\tif (exclude && Array.isArray(exclude)) {\n\t\tcolumns = columns.filter(col => exclude.indexOf(col) === -1);\n\t}\n\tcolumns.forEach(col => {\n\t\tdf = df.transformSeries({\n\t\t\t[col]: value => {\n\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\treturn df;\n}\n\nfunction removeOutliers({\n\tcolumn = \"value\",\n\tlowerThreshold,\n\tupperThreshold\n} = {}) {\n\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\tvalue < lowerThreshold || value > upperThreshold;\n\tlet outliers = this.where(row => outlierCheck(row.value))\n\t\t.generateSeries({\n\t\t\traw: row => row.value,\n\t\t\tflag: ({ flag = [] }) => [\"outlier\", ...flag]\n\t\t})\n\t\t.transformSeries({\n\t\t\tvalue: row => null\n\t\t});\n\tlet df = this.merge(outliers);\n\treturn df;\n}\nfunction reset() {\n\treturn this.withSeries({\n\t\tvalue: row =>\n\t\t\trow.flag && Array.isArray(row.flag) && row.flag.length > 0\n\t\t\t\t? row.raw\n\t\t\t\t: row.value\n\t}).dropSeries([\"flag\", \"raw\"]);\n}\nfunction group(interval, toArray) {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\tlet groups = this.groupBy(dateComparison);\n\treturn groups;\n}\nfunction upsample([duration, value], fillType = \"avg\") {\n\t// Dont use this b/c it has the raw and flag values\n\tlet df = this.fillGaps(\n\t\tgapExists([duration, value]),\n\t\tgapFill(fillType, [duration, value])\n\t);\n\treturn df;\n}\nfunction downsample([duration, value], fillType = \"sum\") {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t}\n\tlet dateComparison = row => row.date.startOf(duration);\n\tlet valueColumns = this.getValueColumns();\n\tif (value) {\n\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t}\n\tlet df = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\t...fromPairs([\n\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t}),\n\t\t\t\t\t...group\n\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => dayjs(row.date).toDate());\n\treturn df;\n}\nfunction populate(value, type = \"avg\") {\n\tlet v;\n\tswitch (type) {\n\t\tcase \"fill\":\n\t\t\tv = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = value / this.count();\n\t\t\tbreak;\n\t}\n\tlet df = this.generateSeries({ value: row => v });\n\treturn df;\n}\nfunction fill() {\n\tlet startDate = this.first().date.toDate(),\n\t\tendDate = this.last().date.toDate();\n\tlet interval = this.getInterval();\n\tlet bdf = Timeseries.blank(startDate, endDate, interval, \"missing\");\n\tlet df = this.joinOuterRight(\n\t\tbdf,\n\t\torigional => origional.date.valueOf(),\n\t\tblank => blank.date.valueOf(),\n\t\t(data, fill) => {\n\t\t\tif (data) {\n\t\t\t\treturn data;\n\t\t\t} else {\n\t\t\t\treturn fill;\n\t\t\t}\n\t\t}\n\t);\n\treturn df;\n}\nfunction reduceToValue(columnNames) {\n\tfunction chooseValue(row, columnNames = []) {\n\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\treturn values[0] || 0;\n\t}\n\tlet df = this.generateSeries({\n\t\tvalue: row => chooseValue(row, columnNames)\n\t}).subset([\"date\", \"value\"]);\n\treturn df;\n}\n// Specific Functions\nfunction addBaselineDelta(baselineDF) {\n\t// Only Change in Year\n\tif (!(baselineDF instanceof Timeseries))\n\t\tbaselineDF = new Timeseries(baselineDF).setDateIndex();\n\tlet dfwb;\n\tif (baselineDF.count() > 1) {\n\t\tlet interval = this.getInterval();\n\t\tlet baselineInterval = baselineDF.interval;\n\t\tif (!isEqual(interval, baselineInterval)) {\n\t\t\tconsole.error(interval, baselineInterval);\n\t\t\tthrow new Error(\"baseline and data intervals do not match\");\n\t\t}\n\t\tlet indexer;\n\t\tswitch (interval[0]) {\n\t\t\tcase \"day\":\n\t\t\t\tindexer = date => `${date.month()}-${date.date()}`;\n\t\t\t\tbreak;\n\t\t\tcase \"month\":\n\t\t\t\tindexer = date => date.month();\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tindexer = date => 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet indexedBaseline = baselineDF.withIndex(row => indexer(row.date));\n\t\tlet getBaselineValue = index => {\n\t\t\tlet at = indexedBaseline.at(index);\n\t\t\tif (at && has(at, \"value\")) {\n\t\t\t\treturn at.value;\n\t\t\t} else {\n\t\t\t\treturn indexedBaseline.getSeries(\"value\").average();\n\t\t\t}\n\t\t};\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => getBaselineValue(indexer(row.date))\n\t\t});\n\t} else {\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => baselineDF.first().value\n\t\t});\n\t}\n\tdfwb = dfwb.generateSeries({\n\t\tdelta: row => calculateChange(row.baseline, row.value)\n\t});\n\treturn dfwb;\n}\nfunction annualMonthlyAverage({ startDate, endDate }) {\n\tlet months = this.downsample([\"month\", 1], \"sum\").between(startDate, endDate);\n\tlet avg = months.getSeries(\"value\").average();\n}\n// Building Functions\nfunction annualIntensity(normalizeValue = 1) {\n\tlet interval = this.getInterval();\n\tlet annual = this.groupBy(row => row.date.year())\n\t\t.select(group => {\n\t\t\tlet startDate = group.first().date;\n\t\t\tlet endDate = group\n\t\t\t\t.last()\n\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\treturn {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\t...fromPairs(\n\t\t\t\t\tthis.getValueColumns().map(col => [\n\t\t\t\t\t\tcol,\n\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.renameSeries({ startDate: \"date\" })\n\t\t.dropSeries(\"endDate\");\n\treturn annual;\n}\n// Static Methods\nfunction blank(startDate, endDate, [duration, value = 1], flag) {\n\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\tconsole.error(interval);\n\t\tthrow new Error(\"interval type not supported\");\n\t}\n\tstartDate = dayjs(startDate);\n\tendDate = dayjs(endDate);\n\tlet dates = [startDate];\n\tlet interval = intervalToMS([duration, value]);\n\twhile (dates[dates.length - 1].valueOf() < endDate.valueOf()) {\n\t\tdates.push(dayjs(dates[dates.length - 1]).add(value, duration));\n\t}\n\tlet df = new Timeseries(dates.map(date => ({ date }))).setDateIndex();\n\tif (flag)\n\t\tdf = df.generateSeries({\n\t\t\tflag: row => [flag]\n\t\t});\n\treturn df;\n}\nfunction aggregate(dataframes) {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df).setDateIndex());\n\tconst valueColumns = new Set(\n\t\tdataframes.map(df => df.getValueColumns()).reduce((a, b) => a.concat(b), [])\n\t);\n\n\tconst concatenated = dataForge.DataFrame.concat(dataframes)\n\t\t.groupBy(row => row.date)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date;\n\t\t\tlet o = { date };\n\t\t\tvalueColumns.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\treturn o;\n\t\t})\n\t\t.inflate();\n\t// .toArray();\n\treturn new Timeseries(concatenated).setDateIndex();\n\t// return concatenated;\n}\nTimeseries.prototype.setDateIndex = setDateIndex;\nTimeseries.prototype.getInterval = interval;\nTimeseries.prototype.getValueColumns = getValueColumns;\nTimeseries.prototype.getDateRange = dateRange;\nTimeseries.prototype.calculateThresholdOptions = calculateThresholdOptions;\nTimeseries.prototype.claculateStatistics = claculateStatistics;\nTimeseries.prototype.transformAllSeries = transformAllSeries;\nTimeseries.prototype.removeOutliers = removeOutliers;\nTimeseries.prototype.clean = removeOutliers;\nTimeseries.prototype.group = group;\nTimeseries.prototype.downsample = downsample;\nTimeseries.prototype.upsample = upsample;\nTimeseries.prototype.populateSeries = populate;\nTimeseries.prototype.fill = fill;\nTimeseries.prototype.reduceToValue = reduceToValue;\nTimeseries.prototype.annualIntensity = annualIntensity;\nTimeseries.prototype.addBaselineDelta = addBaselineDelta;\n\nTimeseries.blank = blank;\nTimeseries.aggregate = aggregate;\n\nexport default Timeseries;\n","export const annualScale = (start, end) => 365 / dayjs(end).diff(dayjs(start), \"day\");\nexport const calculateChange = (baseline, value) => (value - baseline) / baseline;\n\n"],"names":["valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","val","rval","df","values","deflate","row","x","toArray","std","sampleStandardDeviation","mean","_mean","ndf","generateSeries","ares","R","DataFrame","Math","abs","max","lambdaTest","n","i","alpha","p","pValue","t","degreeOfFreedom","Studentt","inv","tValue","lambda","sqrt","pow","modz","mad","median","modifiedZScoreTest","_median","medianAbsoluteDeviation","outliers","sort","a","b","filter","v","thresholds","upper","min","Infinity","lower","Timeseries","dataForge","removeOutliers","column","lowerThreshold","upperThreshold","this","where","outlierCheck","raw","transformSeries","merge","prototype","setDateIndex","col","getColumnNames","orderBy","valueOf","withIndex","dayjs","toDate","getInterval","ms","start","end","getIndex","window","select","last","first","detectValues","Frequency","Value","add","diff","ceil","getValueColumns","detectTypes","Type","distinct","Column","getSeries","getDateRange","unit","adjustment","startOf","endOf","calculateThresholdOptions","k","filterZeros","filterNegative","noflags","Array","isArray","length","isNaN","count","floor","q1","q3","iqr","esd","dataset","newdf","dataframe","trip","pair","Object","assign","push","outlierValues","outlier","takeWhile","iterations","rosnerTest","box","lowerInner","quantile","upperInner","lowerOuter","upperOuter","claculateStatistics","options","series","average","transformAllSeries","adjustmentFunction","exclude","columns","forEach","[object Object]","clean","group","interval","groupBy","downsample","duration","dateComparison","valueColumns","sum","inflate","upsample","fillGaps","durationValue","pairA","pairB","startDate","gapExists","endDate","newEntries","e","gapFill","populateSeries","type","fill","bdf","blank","joinOuterRight","origional","data","reduceToValue","columnNames","chooseValue","subset","annualIntensity","normalizeValue","year","scaler","annualScale","renameSeries","dropSeries","addBaselineDelta","baselineDF","dfwb","indexer","baselineInterval","isEqual","console","error","month","indexedBaseline","baseline","index","at","has","getBaselineValue","delta","calculateChange","dates","intervalToMS","aggregate","dataframes","Set","reduce","concat","concatenated","o","c"],"mappings":"mjBAEA,IC6CMA,EAAc,CACnBC,aAWIC,GAVJC,WAAEA,EAAFC,SAAcA,EAAdC,WAAwBA,EAAxBC,WAAoCA,MACpCC,cAAEA,EAAFC,aAAiBA,EAAjBC,KAA+BA,EAA/BC,KAAqCA,KAErC,IAGQ,IAFP,CAAC,MAAO,cAAe,UAAW,eAAgB,SAASC,QAC1DV,GAGD,UAAUW,MAAM,2BA6DjB,MA1DiB,QAAbX,GACHC,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAC9B,MAAO,CAACD,EAAKb,EAAWa,OAI1BN,EAAOA,GAAc,CAAC,OAAQ,QACP,gBAAbT,GACVC,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAK9B,MAAO,CAACD,EAHPb,EAAWa,IACVX,EAAa,KACXD,EAASY,GAAOb,EAAWa,KAASV,EAAa,QAKvDI,EAAOA,GAAc,CAAC,OAAQT,IACP,YAAbA,GACVC,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAE9B,MAAO,CAACD,GADEb,EAAWa,GAAOZ,EAASY,IAAQV,MAK/CI,EAAOA,GAAc,CAAC,OAAQT,IACP,iBAAbA,GAA+BO,GACzCN,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAE9B,MAAO,CAACD,EADCR,EAAaC,OAIxBC,EAAOA,GAAc,CAAC,OAAQT,IACP,UAAbA,GACVC,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAO9B,MAAO,CAACD,EALqB,iBAAlBT,EACLA,EAEAA,EAAcS,OAKtBN,EAAOA,GAAc,CAAC,OAAQT,KAE9BC,EAAQW,EACPC,EAAQX,GAAYY,YAAMC,EAAKC,KAC9B,MAAO,CAACD,EAAK,SAGfN,EAAO,CAAC,cAEGR,GAAOQ,KAAAA,KCvGpB,SAASQ,EAAKC,GACZ,IAAIC,EAASD,EAAGE,QAAQC,GAAOA,EAAIC,GAAGC,UAClCC,EAAMC,EAAwBN,GAC9BO,EAAOC,EAAMR,GACjB,GAAY,IAARK,EAAW,CACb,IAAII,EAAMV,EAAGW,eAAe,CAAEC,KAAMT,GAAO,IAC3C,MAAO,CAAEU,EAAG,EAAGP,IAAAA,OAAKE,EAAMR,GAAIU,GAEhC,IAAIA,EAAM,IAAII,EAAU,CACtBb,OAAQA,EAAOL,IAAIQ,KACjBA,EAAAA,EACAQ,KAAMG,KAAKC,IAAIZ,EAAII,GAAQF,OAI/B,MAAO,CAAEO,EADDI,EAAIP,EAAIR,QAAQC,GAAOA,EAAIS,MAAMP,WAC7BL,GAAIU,EAAKJ,IAAAA,OAAKE,GAa5B,SAASU,EAAWC,EAAGC,EAAGC,GACxB,IAAIC,EAXN,SAAgBH,EAAGC,EAAGC,GAEpB,OADQ,EAAIA,GAAS,GAAKF,EAAIC,EAAI,IAU1BG,CAAOJ,EAAGC,EAAGC,GAEjBG,EATN,SAAgBF,EAAGG,GAGjB,OAFS,IAAIC,EAASD,GACXE,IAAIL,GAOPM,CAAON,EADNH,EAAIC,EAAI,GAKjB,MAAO,CAAES,OAFNL,GAAKL,EAAIC,GACVL,KAAKe,MAAMX,EAAIC,EAAI,EAAIL,KAAKgB,IAAIP,EAAG,KAAOL,EAAIC,EAAI,IACnCE,EAAAA,EAAGE,EAAAA,GAwEtB,IAAMQ,EAAO,CAACjD,EAAOkD,EAAKC,WACNnD,EAAQmD,GAAWD,EAEvC,SAASE,EAAmBlC,GAC1B,IAAIiC,EAASE,EAAQnC,GACjBgC,EAAMI,EAAwBpC,GAK9BqC,GAJJrC,EAASA,EACNsC,KAAK,CAACC,EAAGC,IAAMA,EAAID,GACnBE,OAAOC,GAAKA,EAAI,GAChB/C,IAAI+C,GAAK,CAACA,EAAGX,EAAKW,EAAGV,EAAKC,MACPQ,eAClBC,EAAGX,YAAUjB,KAAKC,IAAIgB,IAAS,MAcnC,MAAO,CAAEY,WAAY,CAAEC,MAZX9B,KAAK+B,IACXC,YAAaT,EAAS1C,IAAI+C,GAAKA,EAAE,KAWTK,MAAO,QCpIjCC,EAAaC,EAAUpC,UA6H7B,SAASqC,SAAeC,OACvBA,EAAS,QADcC,eAEvBA,EAFuBC,eAGvBA,cACG,KACH,GAAID,EAAiBC,EAAgB,UAAU7D,MAAM,sBACrD,IAEI6C,EAAWiB,KAAKC,MAAMrD,GAFP,EAACpB,EAAOsE,EAAgBC,IAC1CvE,OACgC0E,GADN1E,OACM0E,EAAAA,CAAatD,EAAIpB,QAChD4B,eAAe,CACf+C,IAAKvD,GAAOA,EAAIpB,MAChBQ,aAASA,KAAAA,EAAO,YAAS,CAAC,aAAcA,MAExCoE,gBAAgB,CAChB5E,MAAOoB,GAAO,OAGhB,OADSoD,KAAKK,MAAMtB,GA6PrBW,EAAWY,UAAUC,aAxYrB,SAAsBC,GACrB,YADqBA,IAAAA,EAAM,SACiB,IAAxCR,KAAKS,iBAAiBxE,QAAQuE,GACjC,UAAUtE,MAAM,+BACjB,YAAYwE,QAAQ9D,GAAOA,EAAI4D,GAAKG,WAAWC,UAAUhE,GACxDiE,EAAMjE,EAAIb,MAAM+E,WAqYlBpB,EAAWY,UAAUS,YAlYrB,WACC,IHvBoBC,EAChBC,EACAC,EG8BJ,OHhCoBF,EGyBFhB,KAAKmB,WACrBC,OAAO,GACPC,OAJsBD,GAAUA,EAAOE,OAASF,EAAOG,SAKvDC,eACAd,QAAQ9D,IAAQA,EAAI6E,WACpBf,QAAQ9D,GAAOA,EAAI8E,OACDH,QAAQG,MH9BxBT,EAAQJ,KACRK,EAAML,IAAQc,IAAIX,IACdY,KAAKX,EAAO,SAAS,IAAS,GAC9B,CAAC,OAAQzD,KAAKqE,KAAKX,EAAIU,KAAKX,EAAO,QAAQ,KACxCC,EAAIU,KAAKX,EAAO,OAAO,IAAS,GACnC,CAAC,QAASzD,KAAKqE,KAAKX,EAAIU,KAAKX,EAAO,SAAS,KAC1CC,EAAIU,KAAKX,EAAO,QAAQ,IAAS,GACpC,CAAC,MAAOzD,KAAKqE,KAAKX,EAAIU,KAAKX,EAAO,OAAO,KACtCC,EAAIU,KAAKX,EAAO,UAAU,IAAS,GACtC,CAAC,OAAQzD,KAAKqE,KAAKX,EAAIU,KAAKX,EAAO,QAAQ,KAE3C,CAAC,SAAUC,EAAIU,KAAKX,EAAO,YG6YpCvB,EAAWY,UAAUwB,gBAtXrB,WACC,YAAYC,cACV9B,MAAMrD,GAAoB,WAAbA,EAAIoF,MACjBC,SAASrF,GAAOA,EAAIsF,QACpBC,UAAU,UACVrF,WAkXH4C,EAAWY,UAAU8B,aA/WrB,SAAmBC,EAAMC,GACxB,IAAIrB,EAAQJ,EAAMb,KAAKuB,QAAQxF,MAC9BmF,EAAML,EAAMb,KAAKsB,OAAOvF,MAKzB,OAJIuG,IACHrB,EAAQA,EAAMsB,QAAQD,GACtBpB,EAAMA,EAAIsB,MAAMF,IAEVpB,EAAIU,KAAKX,EAAOoB,IAyWxB3C,EAAWY,UAAUmC,0BAtWrB,gBAAmCC,EAClCA,EADkCC,YAElCA,GAAc,EAFoBC,eAGlCA,GAAiB,cACd,KACCC,EAAU7C,KAAKC,MAClBrD,GACCA,MAAAA,EAAIZ,MAEH8G,MAAMC,QAAQnG,EAAIZ,OAA6B,IAApBY,EAAIZ,KAAKgH,QAErC/C,MAAMrD,IAAQqG,MAAMrG,EAAIpB,QAAwB,OAAdoB,EAAIpB,OACtC2G,UAAU,SASZ,GARIQ,IAAaE,EAAUA,EAAQ5C,MAAMzE,GAAmB,IAAVA,IAC9CoH,IAAgBC,EAAUA,EAAQ5C,MAAMzE,GAASA,EAAQ,IACxDkH,IACJA,EACCG,EAAQK,QAAU,IACf1F,KAAK2F,MAAwB,IAAlBN,EAAQK,SACnB1F,KAAK+B,IAAQ,IAAM/B,KAAK2F,MAAwB,IAAlBN,EAAQK,WAEvCL,EAAQK,QAAU,EAAG,MAAO,GAChC,IDwEoBxG,EACf0G,EACAC,EACAC,GC3ECjE,WAAYkE,GDzBnB,SAAoBC,EAAcd,EAAQ5E,YAAtB0F,IAAAA,EAAU,aAAId,IAAAA,EAAI,aAAI5E,IAAAA,EAAQ,KAShD,IARA,IAII2F,EAJAC,EAAY,IAAInG,EAAU,CAC5Bb,OAAQ8G,EAAQnH,IAAIQ,KAAQA,EAAAA,OAE1Be,EAAI8F,EAAUvB,UAAU,KAAKe,QAE7BrF,EAAI,EACJkB,EAAW,GACX4E,GAAO,EACJ9F,GAAK6E,GAAG,CACb,IAAIkB,EAAO,GAED,IAAN/F,aACF,IAAIP,EAAEA,EAAFb,GAAKA,EAALQ,KAASA,EAATF,IAAeA,GAAQP,EAAKkH,GAChCD,EAAQhH,EAAGwD,MAAMrD,GAAOA,EAAIS,OAASC,GACrCsG,EAAOC,OAAOC,OAAO,GAAIF,EAAM,CAC7B3G,KAAAA,EACAF,IAAAA,EACA2E,MAAOjF,EACJwD,MAAMrD,GAAOA,EAAIS,OAASC,GAC1B6E,UAAU,KACVZ,QACHjE,EAAAA,kBAGF,IAAIA,EAAEA,EAAFb,GAAKA,EAALQ,KAASA,EAATF,IAAeA,GAAQP,EAAKiH,GAChCA,EAAQhH,EAAGwD,MAAMrD,GAAOA,EAAIS,OAASC,GACrCsG,EAAOC,OAAOC,OAAO,GAAIF,EAAM,CAC7B3G,KAAAA,EACAF,IAAAA,EACA2E,MAAOjF,EACJwD,MAAMrD,GAAOA,EAAIS,OAASC,GAC1B6E,UAAU,KACVZ,QACHjE,EAAAA,OAGJ,IAAIgB,OAAEA,GAAiBX,EAAWC,EAAGC,EAAGC,GAIxC,GAHA8F,EAAOC,OAAOC,OAAO,GAAIF,EAAM,CAAEtF,OAAAA,IACjCS,EAASgF,KAAKH,GACVD,GAAQC,EAAKtG,EAAIsG,EAAKtF,SAAQqF,GAAO,GAC1B,IAAXC,EAAKtG,EAAS,MAClB,GAAIsG,EAAKtG,EAAIsG,EAAKtF,OAAQ,CACxB,GAAIqF,EACF,MAEAA,GAAO,EAGX9F,IAOF,IAAImG,GALJjF,EAAW,IAAIxB,EAAUwB,GACtB3B,eAAe,CACd6G,QAASrH,GAAOA,EAAIU,EAAIV,EAAI0B,SAE7B4F,UAAUtH,GAAOA,EAAIqH,UAErBhE,MAAMrD,GAAOA,EAAI8E,MAAQ,GACzB/E,QAAQC,GAAOA,EAAI8E,OAMtB,MAAO,CACL3C,SAAAA,EACAM,WAPe,CACfI,MAAO,EACPH,MACE0E,EAAcd,QAAU,EAAIc,EAAczE,MAAQC,UAKpD2E,WAAYtG,GC1CWuG,CAAWvB,EAAQ/F,UAAW4F,IAClDrD,WAAYgF,IDuEE3H,ECvEkBmG,EAAQ/F,UD2EtC,CACLuC,WAAY,CACViF,YALAlB,EAAKmB,EAAS7H,EAAQ,MAKL,KAHjB4G,GADAD,EAAKkB,EAAS7H,EAAQ,MACX0G,GAIXoB,WAAYpB,EAAK,EAAIE,EACrBmB,WAAYpB,EAAK,IAAMC,EACvBoB,WAAYrB,EAAK,EAAIC,MC/EpBjE,WAAYZ,GAASG,EAAmBiE,EAAQ/F,WACtD,MAAO,CAAEyG,IAAAA,EAAKc,IAAAA,EAAK5F,KAAAA,IA8UpBiB,EAAWY,UAAUqE,oBA5UrB,SAA6BC,YAAAA,IAAAA,EAAU,IACtC,IAAM/E,OACLA,EAAS,QADJ8C,YAELA,GAAc,EAFTC,eAGLA,GAAiB,GACdgC,EACAC,EAAS7E,KAAKrD,QAAQC,GAAOA,EAAIiD,IAASI,MAAMzE,IAAUyH,MAAMzH,IAChEoH,IAAgBiC,EAASA,EAAO5E,MAAMzE,GAASA,GAAS,IACxDmH,IAAakC,EAASA,EAAO5E,MAAMzE,GAAmB,IAAVA,IAChD,IAAImD,EAASkG,EAAOlG,SAChB1B,EAAO4H,EAAOC,UACd5B,EAAQ2B,EAAO3B,QACfnG,EAAM8H,EAAO9H,MACbwC,EAAMsF,EAAOtF,MACb7B,EAAMmH,EAAOnH,MACbgB,EAAMI,EAAwB+F,EAAO/H,WACrCsG,EAAKmB,EAASM,EAAO/H,UAAW,KAChCuG,EAAKkB,EAASM,EAAO/H,UAAW,KAcpC,MAZY,CACX6B,OAAAA,EACA1B,KAAAA,EACAiG,MAAAA,EACAnG,IAAAA,EACAwC,IAAAA,EACA7B,IAAAA,EACAgB,IAAAA,EACA0E,GAAAA,EACAC,GAAAA,EACAC,IAXSD,EAAKD,IA2ThB1D,EAAWY,UAAUyE,mBA5SrB,SAA4BC,SAAoBC,QAAEA,KAC7CxI,EAAKuD,KACLkF,EAAWA,EAAUzI,EACvBsF,cACA9B,MAAMrD,GAAoB,WAAbA,EAAIoF,MACjBC,SAASrF,GAAOA,EAAIsF,QACpBC,UAAU,UACVrF,UAeF,OAdImI,GAAWnC,MAAMC,QAAQkC,KAC5BC,EAAUA,EAAQ/F,OAAOqB,IAAiC,IAA1ByE,EAAQhJ,QAAQuE,KAEjD0E,EAAQC,QAAQ3E,IACf/D,EAAKA,EAAG2D,gBAAgB,CACvBgF,CAAC5E,GAAMhF,GACFyH,MAAMzH,GACFA,EAEAwJ,EAAmBxJ,OAKvBiB,GAuRRiD,EAAWY,UAAUV,eAAiBA,EACtCF,EAAWY,UAAU+E,MAAQzF,EAC7BF,EAAWY,UAAUgF,MAnQrB,SAQeC,EAAUzI,GACxB,IAA4D,IAAxD,CAAC,OAAQ,MAAO,QAAS,QAAQb,QAAQsJ,GAC5C,UAAUrJ,MAAM,+BAGjB,OADa8D,KAAKwF,QADG5I,GAAOiE,EAAMjE,EAAIb,MAAMwG,QAAQgD,KAyPrD7F,EAAWY,UAAUmF,WA7OrB,WAAuClK,OAAlBmK,EAAUlK,KAC9B,YADsCD,IAAAA,EAAW,QACW,IAAxD,CAAC,OAAQ,MAAO,QAAS,QAAQU,QAAQyJ,GAC5C,UAAUxJ,MAAM,+BACjB,IAAoD,IAAhD,CAAC,MAAO,MAAO,UAAUD,QAAQV,GACpC,UAAUW,MAAM,0CAEjB,IAAIyJ,EAAiB/I,GAAOA,EAAIb,KAAKwG,QAAQmD,GACzCE,EAAe5F,KAAK8B,kBAoDxB,OAnDItG,IACHmK,EAAiB/I,GAAOA,EAAIb,KAAKwG,QAAQmD,GAAU/D,IAAInG,EAAOkK,IAEtD1F,KAAKwF,QAAQG,GACpBtE,OAAOiE,MAGNvJ,KAFYuJ,EAAM/D,QAAQxF,KAAKwG,QAAQmD,IAGpCvJ,EAAU,IACTyJ,EAAavJ,IAAImE,IACnB,IAAIhF,EACJ,OAAQD,GACP,IAAK,SACJC,EAAQ8J,EACN3I,QAAQC,GAAOA,EAAI4D,IACnBP,MAAMb,GAAKA,GACXT,SACF,MACD,IAAK,MACJnD,EAAQ8J,EACN3I,QAAQC,GAAOA,EAAI4D,IACnBP,MAAMb,GAAKA,GACX0F,UACF,MACD,QAECtJ,EAAQ8J,EACN3I,QAAQC,GAAOA,EAAI4D,IACnBP,MAAMb,GAAKA,GACXyG,MAGJ,MAAO,CAACrF,EAAKhF,QAEX8J,EACD7E,iBACAtB,OAAOqB,GAAe,SAARA,GACdrB,OAAOqB,IAAsC,IAA/BoF,EAAa3J,QAAQuE,IACnCnE,IAAImE,IACJ,IAAIhF,EAAQ8J,EACV3I,QAAQC,GAAOA,EAAI4D,IACnByB,WACAnF,UAEF,OADqB,IAAjBtB,EAAMwH,SAAcxH,EAAQA,EAAM,IAC/B,CAACgF,EAAKhF,SAKjBsK,UACAlF,UAAUhE,GAAOiE,EAAMjE,EAAIb,MAAM+E,WAoLpCpB,EAAWY,UAAUyF,SAtPrB,WAAqCxK,OAAlBmK,EAAUlK,KAM5B,gBANoCD,IAAAA,EAAW,OAEtCyE,KAAKgG,SF7KG,SAAEN,EAAUO,EAAgB,WAAO,CAACC,EAAOC,KAC5D,IAAMC,EAAYF,EAAM,GAMxB,OAJc1I,KAAK2F,MAClBtC,EAFesF,EAAM,IAENvE,KAAKwE,EAAWV,GAAU,GAAQO,GAGpC,IEuKbI,CAAU,CAACX,EAAUlK,IFxDP,SACfD,WACCmK,EAAUO,MACXpK,cAAEA,EAAFC,aAAiBA,EAAjBE,KAA+BA,GAAS,SACpC,CAACkK,EAAOC,KAYZ,IATA,IAAMC,EAAYvF,EAAMqF,EAAM,IACxBI,EAAUzF,EAAMsF,EAAM,IAItBvK,EAHQ4B,KAAK2F,MAClBtC,EAAMyF,GAAS1E,KAAKwE,EAAWV,GAAYO,GAEf,EACvBxK,EAAayK,EAAM,GACnBxK,EAAWyK,EAAM,GACjBI,EAAa,GACV5K,EAAa,EAAGA,EAAaC,IAAcD,EAAY,CAC/D,IAAI2G,EAAahH,EACfC,EACA,CAAEE,WAAAA,EAAYC,SAAAA,EAAUC,WAAAA,EAAYC,WAAAA,GACpC,CACCC,cAAAA,EACAC,aAAAA,EACAE,KAAAA,IAGFD,EAAO8E,EAAMuF,GACXzE,KAAKhG,EAAa,GAAKsK,EAAeP,GACtC5E,SACC0F,EAAI,CAACzK,EAAK4E,UAAWkD,OAAOC,OAAO,GAAIxB,EAAY,CAAEvG,KAAAA,KACzDwK,EAAWxC,KAAKyC,GAGjB,OAAOD,GEwBNE,CAAQlL,EAAU,CAACmK,EAAUlK,MAmP/BkE,EAAWY,UAAUoG,eAlLrB,SAAkBlL,EAAOmL,GACxB,IAAIvH,EACJ,gBAFwBuH,IAAAA,EAAO,OAEvBA,GACP,IAAK,OACJvH,EAAI5D,EACJ,MACD,QACC4D,EAAI5D,EAAQwE,KAAKkD,QAInB,OADSlD,KAAK5C,eAAe,CAAE5B,MAAOoB,GAAOwC,KAyK9CM,EAAWY,UAAUsG,KAtKrB,WACC,IAAIR,EAAYpG,KAAKuB,QAAQxF,KAAK+E,SACjCwF,EAAUtG,KAAKsB,OAAOvF,KAAK+E,SACxByE,EAAWvF,KAAKe,cAChB8F,EAAMnH,EAAWoH,MAAMV,EAAWE,EAASf,EAAU,WAazD,OAZSvF,KAAK+G,eACbF,EACAG,GAAaA,EAAUjL,KAAK4E,UAC5BmG,GAASA,EAAM/K,KAAK4E,UACpB,CAACsG,EAAML,IACFK,GAGIL,IA0JXlH,EAAWY,UAAU4G,cApJrB,SAAuBC,GAQtB,OAHSnH,KAAK5C,eAAe,CAC5B5B,MAAOoB,IALR,SAAqBA,EAAKuK,GAEzB,gBAFyBA,IAAAA,EAAc,IAC1BA,EAAY9K,IAAIuB,GAAKhB,EAAIgB,IAAIuB,OAAOC,GAAKA,GACxC,IAAM,GAGNgI,CAAYxK,EAAKuK,KAC7BE,OAAO,CAAC,OAAQ,WA8IpB3H,EAAWY,UAAUgH,gBArFrB,SAAyBC,YAAAA,IAAAA,EAAiB,GACzC,IAAIhC,EAAWvF,KAAKe,cA2BpB,OA1Baf,KAAKwF,QAAQ5I,GAAOA,EAAIb,KAAKyL,QACxCnG,OAAOiE,IACP,IAAIc,EAAYd,EAAM/D,QAAQxF,KAC1BuK,EAAUhB,EACZhE,OACAvF,KAAK4F,IAAI4D,EAAS,IAAM,EAAGA,EAAS,IAAM,SACxCkC,EC3VoB,EAACxG,EAAOC,IAAQ,IAAML,MAAMK,GAAKU,KAAKf,MAAMI,GAAQ,OD2V/DyG,CAAYtB,EAAWE,GACpC,UACCF,UAAAA,EACAE,QAAAA,GACGnK,EACF6D,KAAK8B,kBAAkBzF,IAAImE,GAAO,CACjCA,EACC8E,EACC3I,QAAQC,GAAOA,EAAI4D,IACnBP,MAAMb,GAAKA,GACXyG,MACD4B,EACAF,QAKJzB,UACA6B,aAAa,CAAEvB,UAAW,SAC1BwB,WAAW,YA2DdlI,EAAWY,UAAUuH,iBA3IrB,SAA0BC,GAIzB,IAAIC,EACJ,GAHMD,aAAsBpI,IAC3BoI,EAAa,IAAIpI,EAAWoI,GAAYvH,gBAErCuH,EAAW5E,QAAU,EAAG,CAC3B,IAMI8E,EANAzC,EAAWvF,KAAKe,cAChBkH,EAAmBH,EAAWvC,SAClC,IAAK2C,EAAQ3C,EAAU0C,GAEtB,MADAE,QAAQC,MAAM7C,EAAU0C,OACd/L,MAAM,4CAGjB,OAAQqJ,EAAS,IAChB,IAAK,MACJyC,EAAUjM,GAAWA,EAAKsM,YAAWtM,EAAKA,OAC1C,MACD,IAAK,QACJiM,EAAUjM,GAAQA,EAAKsM,QAEvB,MACD,QACCL,EAAUjM,GAAQ,EAIpB,IAAIuM,EAAkBR,EAAWlH,UAAUhE,GAAOoL,EAAQpL,EAAIb,OAS9DgM,EAAO/H,KAAK5C,eAAe,CAC1BmL,SAAU3L,GATY4L,CAAAA,IACtB,IAAIC,EAAKH,EAAgBG,GAAGD,GAC5B,OAAIC,GAAMC,EAAID,EAAI,SACVA,EAAGjN,MAEH8M,EAAgBnG,UAAU,SAAS2C,WAI1B6D,CAAiBX,EAAQpL,EAAIb,cAG/CgM,EAAO/H,KAAK5C,eAAe,CAC1BmL,SAAU3L,GAAOkL,EAAWvG,QAAQ/F,QAMtC,OAHOuM,EAAK3K,eAAe,CAC1BwL,MAAOhM,GCzUsB,EAAC2L,EAAU/M,KAAWA,EAAQ+M,GAAYA,EDyUzDM,CAAgBjM,EAAI2L,SAAU3L,EAAIpB,UAiGlDkE,EAAWoH,MAzDX,SAAeV,EAAWE,IAAgCtK,OAAtB0J,EAAUlK,EAAQ,KACrD,GAAI,CAAC,SAAU,OAAQ,MAAO,QAAS,QAAQS,QAAQyJ,GAAY,EAElE,MADAyC,QAAQC,MAAM7C,OACJrJ,MAAM,+BAEjBkK,EAAYvF,EAAMuF,GAClBE,EAAUzF,EAAMyF,GAGhB,IAFA,IAAIwC,EAAQ,CAAC1C,GACTb,EHzWgB,SAAElD,EAAM7G,KACxByF,EAAQJ,IAEZ,OADUA,IAAQc,IAAInG,EAAO6G,GAClBT,KAAKX,IGsWD8H,CAAa,CAACrD,EAAUlK,IAChCsN,EAAMA,EAAM9F,OAAS,GAAGrC,UAAY2F,EAAQ3F,WAClDmI,EAAM/E,KAAKlD,EAAMiI,EAAMA,EAAM9F,OAAS,IAAIrB,IAAInG,EAAOkK,IAEtD,IAAIjJ,EAAK,IAAIiD,EAAWoJ,EAAMzM,IAAIN,KAAWA,KAAAA,MAAUwE,eAKvD,OAJIvE,IACHS,EAAKA,EAAGW,eAAe,CACtBpB,KAAMY,GAAO,CAACZ,MAETS,GAyCRiD,EAAWsJ,UAvCX,SAAmBC,GACbnG,MAAMC,QAAQkG,KAAaA,EAAa,CAACA,IAC9CA,EAAaA,EAAW5M,IAAII,GAAM,IAAIiD,EAAWjD,GAAI8D,gBACrD,IAAMqF,EAAe,IAAIsD,IACxBD,EAAW5M,IAAII,GAAMA,EAAGqF,mBAAmBqH,OAAO,CAAClK,EAAGC,IAAMD,EAAEmK,OAAOlK,GAAI,KAGpEmK,EAAe1J,EAAUpC,UAAU6L,OAAOH,GAC9CzD,QAAQ5I,GAAOA,EAAIb,MACnBsF,OAAOiE,IACP,IACIgE,EAAI,CAAEvN,KADGuJ,EAAM/D,QAAQxF,MAG3B,OADA6J,EAAaT,QAAQoE,GAAMD,EAAEC,GAAKjE,EAAM3I,QAAQC,GAAOA,EAAI2M,IAAI1D,OACxDyD,IAEPxD,UAEF,WAAWpG,EAAW2J,GAAc9I"}
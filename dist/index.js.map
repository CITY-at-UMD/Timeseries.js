{"version":3,"file":"index.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n  let start = dayjs();\n  let end = dayjs().add(ms);\n  if (end.diff(start, \"year\", true) >= 1) {\n    return [\"year\", end.diff(start, \"year\")];\n  } else if (end.diff(start, \"month\", true) >= 1) {\n    return [\"month\", end.diff(start, \"month\")];\n  } else if (end.diff(start, \"day\", true) >= 1) {\n    return [\"day\", end.diff(start, \"day\")];\n  } else if (end.diff(start, \"hour\", true) >= 1) {\n    return [\"hour\", end.diff(start, \"hour\")];\n  } else {\n    return [\"minute\", end.diff(start, \"minute\")];\n  }\n};\n\nfunction calculateInterval(df, startDate, endDate) {\n  if (!startDate) startDate = df.first.date;\n  if (!endDate) endDate = df.last.date;\n  function computeInterval(window) {\n    return window.last() - window.first();\n  }\n  const intervals = df\n    .between(startDate, endDate)\n    .getIndex()\n    .window(2)\n    .select(computeInterval)\n    .detectValues()\n    .orderBy(row => row.Frequency);\n\n  let val = intervals.last().Value;\n  return msToInterval(val);\n}\nexport { msToInterval, calculateInterval };\n","import dayjs from \"dayjs\";\nimport _ from \"lodash\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration, true) /\n      durationValue\n  );\n\n  if (gapSize > 0) return true;\n  return false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize;\n  if (interval === \"quarterHour\") {\n    gapSize = Math.floor(\n      dayjs(endDate).diff(startDate, \"minutes\") / 15\n    );\n  } else {\n    gapSize = dayjs(endDate).diff(startDate, interval);\n  }\n  if (maxGap && maxGap > gapSize) return false;\n  if (gapSize > 0) return true;\n  return false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const newEntries = [];\n\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let date = dayjs(startDate)\n      .add((entryIndex + 1) * durationValue, duration)\n      .toDate();\n    newEntries.push([\n      date.valueOf(),\n      { date, value: null, ...(flag && { flag: [flag] }) }\n    ]);\n  }\n  return newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n  fillType,\n  { startValue, endValue, entryIndex, numEntries },\n  { overrideValue, dateFunction, date, flag }\n) => {\n  if (\n    [\n      \"pad\",\n      \"interpolate\",\n      \"average\",\n      \"dateFunction\",\n      \"value\"\n    ].indexOf(fillType) === -1\n  ) {\n    throw new Error(\"fill Type not supported\");\n  }\n  let value;\n  if (fillType === \"pad\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, startValue[key]];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", \"pad\"];\n  } else if (fillType === \"interpolate\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv =\n          startValue[key] +\n          (entryIndex + 1) *\n            ((endValue[key] - startValue[key]) /\n              (numEntries + 1));\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"average\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = (startValue[key] + endValue[key]) / numEntries;\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"dateFunction\" && dateFunction) {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = dateFunction(date);\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"value\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv;\n        if (typeof overrideValue === \"number\") {\n          nv = overrideValue;\n        } else {\n          nv = overrideValue[key];\n        }\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, null];\n      })\n    );\n    flag = [\"fill\"];\n  }\n  return { ...value, flag };\n};\n\nconst gapFill = (\n  fillType,\n  [duration, durationValue],\n  { overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n  // Fill values forward.\n\n  const startDate = dayjs(pairA[0]);\n  const endDate = dayjs(pairB[0]);\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const startValue = pairA[1];\n  const endValue = pairB[1];\n  const newEntries = [];\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let adjustment = valueFiller(\n        fillType,\n        { startValue, endValue, entryIndex, numEntries },\n        {\n          overrideValue,\n          dateFunction,\n          flag\n        }\n      ),\n      date = dayjs(startDate)\n        .add((entryIndex + 1) * durationValue, duration)\n        .toDate();\n    let e = [\n      date.valueOf(),\n      Object.assign({}, adjustment, { date })\n    ];\n    newEntries.push(e);\n  }\n\n  return newEntries;\n};\n\nexport {\n  gapExists,\n  gapFill,\n  gapFillBlank,\n  gapFillNull,\n  valueFiller\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport fromPairs from \"lodash/fromPairs\";\nimport {\n  gapExists,\n  gapFill,\n  gapFillBlank\n} from \"./lib/Timeseries.fill\";\nimport {\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nclass Timeseries extends DataFrame {\n  constructor(data = []) {\n    if (\n      data instanceof DataFrame ||\n      data instanceof Timeseries\n    ) {\n      data = data.toArray();\n    }\n    // sort\n    data = data.sort(\n      (a, b) =>\n        new Date(a.date).valueOf() - new Date(b.date).valueOf()\n    );\n    let config = {\n      values: data,\n      index: data.map(({ date }) => new Date(date).valueOf()),\n      considerAllRows: true\n    };\n    super(config);\n  }\n  get interval() {\n    let startDate = this.first().date;\n    let endDate = this.last().date;\n    function computeInterval(window) {\n      return window.last() - window.first();\n    }\n    const intervals = this.between(startDate, endDate)\n      .getIndex()\n      .window(2)\n      .select(computeInterval)\n      .detectValues()\n      .orderBy(row => row.Frequency)\n      .orderBy(row => row.Value);\n    let val = intervals.last().Value;\n    return msToInterval(val);\n  }\n  dateRange(unit, adjustment) {\n    let start = dayjs(this.first().date),\n      end = dayjs(this.last().date);\n    if (adjustment) {\n      start = start.startOf(adjustment);\n      end = end.endOf(adjustment);\n    }\n    return end.diff(start, unit);\n  }\n  at(date) {\n    return super.at(new Date(date).valueOf());\n  }\n  calculateThresholds({ k, filterZeros = true } = {}) {\n    let noflags = this.where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        (Array.isArray(row.flag) && row.flag.length === 0)\n    )\n      .where(row => !isNaN(row.value) && row.value !== null)\n      .getSeries(\"value\");\n    if (filterZeros)\n      noflags = noflags.where(value => value !== 0);\n    if (!k) {\n      k =\n        noflags.count() < 1000\n          ? Math.floor(noflags.count() * 0.15)\n          : Math.min(\n              ...[1000, Math.floor(noflags.count() * 0.02)]\n            );\n    }\n    if (noflags.count() < 5) return {};\n    let { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n    let { thresholds: box } = boxPlotTest(noflags.toArray());\n    let { thresholds: modz } = modifiedZScoreTest(\n      noflags.toArray()\n    );\n    return { esd, box, modz };\n  }\n  removeOutliers({ lowerThreshold, upperThreshold } = {}) {\n    if (lowerThreshold > upperThreshold)\n      throw new Error(\"thresholds invalid\");\n    let outlierCheck = (value, lowerThreshold, upperThreshold) =>\n      value < lowerThreshold || value > upperThreshold;\n    let df = this.generateSeries({\n      raw: row =>\n        outlierCheck(row.value, lowerThreshold, upperThreshold)\n          ? row.value\n          : null,\n      flag: row =>\n        outlierCheck(row.value, lowerThreshold, upperThreshold)\n          ? [\"outlier\"]\n          : null\n    }).transformSeries({\n      value: value =>\n        outlierCheck(value, lowerThreshold, upperThreshold)\n          ? null\n          : value\n    });\n    return df;\n  }\n  reset() {\n    return this.withSeries({\n      value: row =>\n        row.raw && !isNaN(row.raw) ? row.raw : row.value\n    }).dropSeries([\"flag\", \"raw\"]);\n  }\n  group(interval, toArray) {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    let dateComparison = row =>\n      dayjs(row.date).startOf(interval);\n    let groups = this.groupBy(dateComparison);\n    return groups;\n  }\n  // Not Working Yet, downsample and upsample independently work\n  resample([duration, value = 1], fillType) {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    let interval = this.interval;\n    if (isEqual(interval, [duration, value])) {\n      return this;\n    }\n    let d0 = dayjs(0);\n    let currentSampleDiff = dayjs(0)\n      .add(interval[1], interval[0])\n      .diff(d0);\n    let newSampleDiff = dayjs(0)\n      .add(value, duration)\n      .diff(d0);\n    if (currentSampleDiff < newSampleDiff) {\n      return this.downsample([duration, value], fillType);\n    } else {\n      return this.upsample([duration, value], fillType);\n    }\n  }\n  upsample([duration, value], fillType = \"avg\") {\n    // Dont use this b/c it has the raw and flag values\n    let df = this.fillGaps(\n      gapExists([duration, value]),\n      gapFill(fillType, [duration, value])\n    );\n    return df;\n  }\n  downsample([duration, value], fillType = \"sum\") {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    if ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n      throw new Error(\"aggregation type not suppported, only:\");\n    }\n    let dateComparison = row =>\n      dayjs(row.date).startOf(duration);\n    if (value)\n      dateComparison = row =>\n        dayjs(row.date)\n          .startOf(duration)\n          .add(value, duration);\n    let df = this.groupBy(dateComparison)\n      .select(group => {\n        const date = dayjs(group.first().date)\n          .startOf(duration)\n          .toDate();\n        return {\n          date,\n          ...fromPairs(\n            group\n              .getColumnNames()\n              .filter(col => col !== \"date\")\n              .map(col => {\n                let value;\n                switch (fillType) {\n                  case \"median\":\n                    value = group\n                      .deflate(row => row[col])\n                      .median();\n                    break;\n                  case \"avg\":\n                    value = group\n                      .deflate(row => row[col])\n                      .average();\n                    break;\n                  default:\n                    // sum\n                    value = group.deflate(row => row[col]).sum();\n                    break;\n                }\n                return [col, value];\n              })\n          )\n        };\n      })\n      .inflate()\n      .withIndex(row => row.date.valueOf());\n    return df;\n  }\n  calculateStatistics({\n    column = \"value\",\n    filterZeros = false,\n    filterNegative = true\n  } = {}) {\n    let series = this.deflate(row => row[columnName]).where(\n      value => !isNaN(value)\n    );\n    if (filterNegative)\n      series = series.where(value => value >= 0);\n    if (filterZeros) series = series.where(value => value !== 0);\n    let median = series.median();\n    let mean = series.average();\n    let count = series.count();\n    let std = series.std();\n    let min = series.min();\n    let max = series.max();\n    let mad = medianAbsoluteDeviation(series.toArray());\n    let q1 = quantile(series.toArray(), 0.25);\n    let q3 = quantile(series.toArray(), 0.75);\n    let iqr = q3 - q1;\n    let stats = {\n      median,\n      mean,\n      count,\n      std,\n      min,\n      max,\n      mad,\n      q1,\n      q3,\n      iqr\n    };\n    return stats;\n  }\n  dataQuality() {\n    let count = this.count();\n    let valid = this.getSeries(\"flag\")\n      .where(\n        value =>\n          value === null ||\n          value === undefined ||\n          (Array.isArray(value) && value.length === 0)\n      )\n      .count();\n    let missing = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"missing\") !== -1)\n      .count();\n    let invalid = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"outlier\") !== -1)\n      .count();\n    let zeroFill = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"zeroFill\") !== -1)\n      .count();\n    let breakdown = {\n      valid: valid / count,\n      missing: missing / count,\n      invalid: invalid / count\n    };\n    let report = {\n      accuracy: 0,\n      completeness: 0,\n      consistency: 0\n    };\n    return {};\n  }\n  populate(value, type = \"avg\") {\n    let v;\n    switch (type) {\n      case \"fill\":\n        v = value;\n        break;\n      default:\n        v = value / this.getIndex().count();\n        break;\n    }\n    let df = this.generateSeries({ value: row => v });\n    return df;\n  }\n  fill(interval, fillType) {\n    // let interval = this.interval;\n    if (!interval || !Array.isArray(interval))\n      interval = this.interval;\n    let ndf = this.fillGaps(\n      gapExists(interval),\n      gapFill(fillType, interval)\n    );\n    return new Timeseries(ndf);\n  }\n  static blank(startDate, endDate, [duration, value = 1]) {\n    if (\n      [\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(\n        duration\n      ) < 0\n    ) {\n      console.error(interval);\n      throw new Error(\"interval type not supported\");\n    }\n    let df = new Timeseries([\n      { date: new Date(startDate) },\n      { date: new Date(endDate) }\n    ])\n      .fillGaps(\n        gapExists([duration, value]),\n        gapFillBlank([duration, value])\n      )\n      .between(startDate, endDate);\n    return new Timeseries(df);\n  }\n  static aggregate(dataframes) {\n    if (!Array.isArray(dataframes)) dataframes = [dataframes];\n    dataframes = dataframes.map(df => new Timeseries(df));\n    const concatenated = DataFrame.concat(dataframes)\n      .groupBy(row => row.date)\n      .select(group => {\n        const date = group.first().date;\n        let o = { date };\n        group\n          .getColumnNames()\n          .filter(c => c !== \"date\")\n          .forEach(\n            c => (o[c] = group.deflate(row => row[c]).sum())\n          );\n        return o;\n      })\n      .inflate()\n      .toArray();\n    return new Timeseries(concatenated);\n  }\n}\nexport default Timeseries;\n"],"names":["gapExists","duration","durationValue","pairA","pairB","startDate","Math","floor","dayjs","diff","valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","gapFill","endDate","newEntries","adjustment","add","toDate","e","valueOf","Object","assign","push","data","DataFrame","Timeseries","toArray","config","values","sort","a","b","Date","index","considerAllRows","dateRange","unit","start","this","first","end","last","startOf","endOf","at","calculateThresholds","k","filterZeros","noflags","where","row","Array","isArray","length","isNaN","getSeries","count","min","esd","rosnerTest","thresholds","box","boxPlotTest","modz","modifiedZScoreTest","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","generateSeries","raw","transformSeries","reset","withSeries","dropSeries","group","interval","groupBy","resample","isEqual","d0","downsample","upsample","fillGaps","dateComparison","select","getColumnNames","filter","col","deflate","median","average","sum","inflate","withIndex","calculateStatistics","filterNegative","series","columnName","mean","std","max","mad","medianAbsoluteDeviation","q1","quantile","q3","iqr","dataQuality","populate","type","v","getIndex","fill","blank","console","error","df","gapFillBlank","between","aggregate","dataframes","concat","o","c","forEach","ms","window","detectValues","orderBy","Frequency","Value"],"mappings":"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"}
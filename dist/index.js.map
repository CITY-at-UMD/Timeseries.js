{"version":3,"file":"index.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/lib/Timeseries.statistics.js","../src/lib/misc.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\nconst intervalToMS = ([unit, value]) => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(value, unit);\n\treturn end.diff(start);\n};\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, intervalToMS, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nimport { mean } from \"simple-statistics\";\nconst gapExists = ([duration, durationValue = 1]) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration, true) / durationValue\n\t);\n\n\tif (gapSize > 0) return true;\n\treturn false;\n};\n\nconst valueFiller = (\n\tfillType,\n\t{ startValue, endValue, entryIndex, numEntries },\n\t{ overrideValue, dateFunction, date, flag }\n) => {\n\tif (\n\t\t[\"pad\", \"interpolate\", \"average\", \"dateFunction\", \"value\"].indexOf(\n\t\t\tfillType\n\t\t) === -1\n\t) {\n\t\tthrow new Error(\"fill Type not supported\");\n\t}\n\tlet value;\n\tif (fillType === \"pad\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, startValue[key]];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", \"pad\"];\n\t} else if (fillType === \"interpolate\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv =\n\t\t\t\t\tstartValue[key] +\n\t\t\t\t\t(entryIndex + 1) *\n\t\t\t\t\t\t((endValue[key] - startValue[key]) / (numEntries + 1));\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"average\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = (startValue[key] + endValue[key]) / numEntries;\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"dateFunction\" && dateFunction) {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = dateFunction(date);\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"value\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv;\n\t\t\t\tif (typeof overrideValue === \"number\") {\n\t\t\t\t\tnv = overrideValue;\n\t\t\t\t} else {\n\t\t\t\t\tnv = overrideValue[key];\n\t\t\t\t}\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, null];\n\t\t\t})\n\t\t);\n\t\tflag = [\"fill\"];\n\t}\n\treturn { ...value, flag };\n};\n\nconst gapFill = (\n\tfillType,\n\t[duration, durationValue],\n\t{ overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n\t// Fill values forward.\n\n\tconst startDate = dayjs(pairA[0]);\n\tconst endDate = dayjs(pairB[0]);\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst startValue = pairA[1];\n\tconst endValue = pairB[1];\n\tconst newEntries = [];\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet adjustment = valueFiller(\n\t\t\t\tfillType,\n\t\t\t\t{ startValue, endValue, entryIndex, numEntries },\n\t\t\t\t{\n\t\t\t\t\toverrideValue,\n\t\t\t\t\tdateFunction,\n\t\t\t\t\tflag\n\t\t\t\t}\n\t\t\t),\n\t\t\tdate = dayjs(startDate)\n\t\t\t\t.add((entryIndex + 1) * durationValue, duration)\n\t\t\t\t.toDate();\n\t\tlet e = [date.valueOf(), Object.assign({}, adjustment, { date })];\n\t\tnewEntries.push(e);\n\t}\n\n\treturn newEntries;\n};\n\n// Basic Fill Functions\nconst averageMonthlyMap = df =>\n\tnew Map(\n\t\tdf\n\t\t\t.group(\"month\")\n\t\t\t.select(group => ({\n\t\t\t\tmonth: group.first().date.month(),\n\t\t\t\tvalue: group\n\t\t\t\t\t.getSeries(\"value\")\n\t\t\t\t\t.where(v => v)\n\t\t\t\t\t.average()\n\t\t\t}))\n\t\t\t.toArray()\n\t\t\t.map(({ month, value }) => [month, value])\n\t);\nconst annualMonthlyAverageMap = df =>\n\tnew Map(\n\t\tdf\n\t\t\t.groupBy(row => row.date.year())\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date.startOf(\"year\");\n\t\t\t\tlet ts = new Timeseries(group).downsample([\"month\", 1], \"avg\");\n\t\t\t\tlet avg = ts.getSeries(\"value\").average();\n\t\t\t\tlet map = averageMonthlyMap(ts);\n\t\t\t\tmap.set(\"avg\", avg);\n\t\t\t\treturn [date.year(), map];\n\t\t\t})\n\t\t\t.toArray()\n\t);\nconst monthlyRollingAverageMap = (\n\tdf,\n\t{ years = 3, series = \"value\", aggregator = \"average\" } = {}\n) => {\n\tlet months = df\n\t\t.groupBy(row => row.date.startOf(\"month\").toDate())\n\t\t.select(group => {\n\t\t\tlet date = group.first().date.startOf(\"month\");\n\t\t\tlet value = group\n\t\t\t\t.getSeries(series)\n\t\t\t\t.where(v => v)\n\t\t\t\t.average();\n\t\t\treturn { date, value };\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => row.date.toDate())\n\t\t.bake();\n\tlet data = months\n\t\t.groupBy(row => row.date.month())\n\t\t.select(group => {\n\t\t\tlet values = new Map(\n\t\t\t\tgroup\n\t\t\t\t\t.rollingWindow(years)\n\t\t\t\t\t.select(window => [\n\t\t\t\t\t\twindow.last().date.year(),\n\t\t\t\t\t\twindow.getSeries(series).average()\n\t\t\t\t\t])\n\t\t\t);\n\t\t\tgroup\n\t\t\t\t.where(row => !values.has(row.date.year()))\n\t\t\t\t.forEach(row => {\n\t\t\t\t\tlet value =\n\t\t\t\t\t\tmonths.before(row.date.toDate()).count() > 0\n\t\t\t\t\t\t\t? months.before(row.date.toDate()).last()[series]\n\t\t\t\t\t\t\t: months.getSeries(series).average();\n\t\t\t\t\tvalues.set(row.date.year(), value);\n\t\t\t\t});\n\n\t\t\tlet month = group.first().date.month();\n\t\t\treturn [month, values];\n\t\t})\n\t\t.toArray();\n\treturn new Map(data);\n};\n\nconst fillMonthlyByMap = monthMap => row => monthMap.get(row.date.month());\nconst fillMonthlyBAnnualyMap = annualMonthlyMap => row => {\n\tlet month = row.date.month(),\n\t\tyear = row.date.year();\n\tif (annualMonthlyMap.has(month)) {\n\t\tif (annualMonthlyMap.has(month)) {\n\t\t\treturn  annualMonthlyMap.get(month).get(year);\n\t\t} else {\n\t\t\treturn mean([...annualMonthlyMap.get(month).values()]);\n\t\t}\n\t} else {\n\t\treturn mean(\n\t\t\t[...annualMonthlyMap.values()].map(m =>\n\t\t\t\t[...m.values()].reduce((a, b) => a.concat(b), [])\n\t\t\t)\n\t\t);\n\t}\n};\n\nconst pad = (df, { validOnly = true, series = \"value\" } = {}) => row => {\n\tlet values = df\n\t\t.before(row.date.toDate())\n\t\t.getSeries(series)\n\t\t.where(v => v);\n\tlet value = values.count() > 0 ? values.last() : 0;\n\t// console.log(row.date.toDate(), value);\n\treturn value;\n};\nconst annualAverage = (\n\tdf,\n\t{ validOnly = true, series = \"value\", years = 3, defaultValue } = {}\n) => row => {\n\tlet subset = df\n\t\t.subset([\"date\", series])\n\t\t.after(row.date.subtract(years, \"year\").toDate())\n\t\t.before(row.date.toDate())\n\t\t.bake();\n\tlet values = subset\n\t\t.where(r => r.date.month() === row.date.month())\n\t\t.where(r => r.date.date() === row.date.date())\n\t\t.where(r => r.date.hour() === row.date.hour())\n\t\t.where(r => r.date.minute() === row.date.minute())\n\t\t.getSeries(series)\n\t\t.where(v => v);\n\n\tlet value;\n\tif (values.count() < years) {\n\t\tvalue = values\n\t\t\t.appendPair([\n\t\t\t\tnull,\n\t\t\t\tsubset\n\t\t\t\t\t.getSeries(series)\n\t\t\t\t\t.where(v => v)\n\t\t\t\t\t.average()\n\t\t\t])\n\t\t\t.average();\n\t} else {\n\t\tvalue = values.average();\n\t}\n\t// console.log(row.date.toDate(), values.toArray(), value);\n\treturn value;\n};\nexport {\n\tgapExists,\n\tgapFill,\n\taverageMonthlyMap,\n\tfillMonthlyByMap,\n\tpad,\n\tannualAverage,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap\n};\n","// Source: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm\n// https://vsp.pnnl.gov/help/Vsample/Rosners_Outlier_Test.htm\n// https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm\n// https://www.math.ucla.edu/~tom/distributions/KolSmir2.html?\nimport { DataFrame } from \"data-forge\";\nimport {\n  sampleStandardDeviation,\n  mean as _mean,\n  max,\n  median as _median,\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nimport { Studentt } from \"distributions\";\nimport dayjs from \"dayjs\";\n\nfunction rval(df) {\n  let values = df.deflate(row => row.x).toArray();\n  let std = sampleStandardDeviation(values);\n  let mean = _mean(values);\n  if (std === 0) {\n    let ndf = df.generateSeries({ ares: row => 0 });\n    return { R: 0, std, mean, df: ndf };\n  }\n  let ndf = new DataFrame({\n    values: values.map(x => ({\n      x,\n      ares: Math.abs(x - mean) / std\n    }))\n  });\n  let R = max(ndf.deflate(row => row.ares).toArray());\n  return { R, df: ndf, std, mean };\n}\n\nfunction pValue(n, i, alpha) {\n  let p = 1 - alpha / (2 * (n - i + 1));\n  return p;\n}\nfunction tValue(p, degreeOfFreedom) {\n  let qt = new Studentt(degreeOfFreedom);\n  let t = qt.inv(p);\n  return t;\n}\n//\nfunction lambdaTest(n, i, alpha) {\n  let p = pValue(n, i, alpha);\n  let df = n - i - 1;\n  let t = tValue(p, df);\n  let lambda =\n    (t * (n - i)) /\n    Math.sqrt((n - i - 1 + Math.pow(t, 2)) * (n - i + 1));\n  return { lambda, p, t };\n}\nfunction rosnerTest(dataset = [], k = 10, alpha = 0.05) {\n  let dataframe = new DataFrame({\n    values: dataset.map(x => ({ x }))\n  });\n  let n = dataframe.getSeries(\"x\").count();\n  let newdf;\n  let i = 1;\n  let outliers = [];\n  let trip = false;\n  while (i <= k) {\n    let pair = {};\n    let s = Date.now();\n    if (i === 1) {\n      let { R, df, mean, std } = rval(dataframe);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    } else {\n      let { R, df, mean, std } = rval(newdf);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    }\n    let { lambda, p, t } = lambdaTest(n, i, alpha);\n    pair = Object.assign({}, pair, { lambda });\n    outliers.push(pair);\n    if (trip && pair.R > pair.lambda) trip = false;\n    if (pair.R === 0) break;\n    if (pair.R < pair.lambda) {\n      if (trip) {\n        break;\n      } else {\n        trip = true;\n      }\n    }\n    i++;\n  }\n  outliers = new DataFrame(outliers)\n    .generateSeries({\n      outlier: row => row.R > row.lambda\n    })\n    .takeWhile(row => row.outlier);\n  let outlierValues = outliers\n    .where(row => row.Value > 0)\n    .deflate(row => row.Value);\n  let thresholds = {\n    lower: 0,\n    upper:\n      outlierValues.count() > 0 ? outlierValues.min() : Infinity\n  };\n  return {\n    outliers,\n    thresholds,\n    iterations: i\n  };\n}\nconst modz = (value, mad, median) => {\n  return (0.6745 * (value - median)) / mad;\n};\nfunction modifiedZScoreTest(values) {\n  let median = _median(values);\n  let mad = medianAbsoluteDeviation(values);\n  values = values\n    .sort((a, b) => b - a)\n    .filter(v => v > 0)\n    .map(v => [v, modz(v, mad, median)]);\n  let outliers = values.filter(\n    ([v, modz]) => Math.abs(modz) >= 3.5\n  );\n  let upper = Math.min(\n    ...[Infinity, ...outliers.map(v => v[0])]\n  );\n  // let score,\n  // \tvalue,\n  // \tthreshold = Infinity,\n  // \tindex = 0;\n  // do {\n  // \tvalue = values[index];\n  // \tscore = modz(value, mad, median);\n  // \tif (Math.abs(score) >= 3.5) threshold = value;\n  // } while (score >= 3.5);\n  return { thresholds: { upper, lower: 0 } };\n}\nfunction boxPlotTest(values) {\n  let q1 = quantile(values, 0.25);\n  let q3 = quantile(values, 0.75);\n  let iqr = q3 - q1;\n  return {\n    thresholds: {\n      lowerInner: q1 - 1.5 * iqr,\n      upperInner: q1 - 3 * iqr,\n      lowerOuter: q3 + 1.5 * iqr,\n      upperOuter: q3 + 3 * iqr\n    }\n  };\n}\nfunction calculateOutlierThresholds(\n  df,\n  { k, filterZeros = true } = {}\n) {\n  let values = df\n    .where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        Array.isArray(row.flag)\n    )\n    .where(row => !isNaN(row.value) && row.value !== null)\n    .getSeries(\"value\")\n    .bake();\n  if (filterZeros) values = values.where(value => value > 0);\n  if (!k) {\n    k =\n      values.count() < 1000\n        ? Math.floor(values.count() * 0.15)\n        : Math.min(...[1000, Math.floor(values.count() * 0.02)]);\n  }\n  if (values.count < 5) return {};\n  let { outliers, threshold } = rosnerTest(values.toArray(), k);\n  return { outliers, threshold };\n}\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  zeroGroups.forEach(dff => {\n    dff = dff.transformSeries({\n      value: value => null,\n      flag: value => [\"zero\"]\n    });\n    df = DataFrame.merge([df, dff]);\n  });\n  return df;\n}\nfunction isOutlier(value, { lower, upper }) {\n  if (value < lower || value >= upper) {\n    return true;\n  }\n  return false;\n}\nfunction validMean(df) {\n  let values = df\n    .getSeries(\"value\")\n    .where(value => typeof value === \"number\");\n  return values.average();\n}\nfunction validMonthlyMeanMap(df) {\n  let dateComparison = row =>\n    dayjs(row.date)\n      .startOf(\"month\")\n      .month();\n\n  df = df\n    .where(row => typeof row.value === \"number\")\n    .groupBy(dateComparison)\n    .select(group => ({\n      month: new Date(group.first().date).getMonth(),\n      value: group.deflate(row => row.value).average()\n    }));\n  return new Map(\n    df.toArray().map(({ month, value }) => [month, value])\n  );\n}\n\nfunction quality(df) {\n  let count = df.getIndex().count();\n  let valid = df\n    .getSeries(\"flag\")\n    .where(\n      value =>\n        value === null ||\n        (Array.isArray(value) && value.length === 0)\n    )\n    .count();\n  let missing = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"missing\") !== -1)\n    .count();\n  let dirty = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"clean\") !== -1)\n    .count();\n  let zerod = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"zero\") !== -1)\n    .count();\n  let breakdown = {\n    valid: valid / count,\n    missing: missing / count,\n    invalid: (dirty + zerod) / count\n  };\n  let report = {\n    accuracy: (1 - dirty / count) * 4,\n    completeness: 4 * breakdown.valid,\n    consistency: 4 * ((count - missing - zerod) / count)\n  };\n  return { breakdown, report, count };\n}\n\nexport {\n  rosnerTest,\n  modifiedZScoreTest,\n  boxPlotTest,\n  calculateOutlierThresholds,\n  zeroReplacement,\n  isOutlier,\n  validMean,\n  validMonthlyMeanMap,\n  quality\n};\n","import dayjs from \"dayjs\";\nexport const annualScale = (start, end) =>\n\t365 / dayjs(end).diff(dayjs(start), \"day\");\nexport const calculateChange = (baseline, value) =>\n\t(value - baseline) / baseline;\n","import dayjs from \"dayjs\";\nimport dataForge from \"data-forge\";\nimport { msToInterval, intervalToMS } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport has from \"lodash/has\";\nimport get from \"lodash/get\";\nimport fromPairs from \"lodash/fromPairs\";\nimport {\n\tgapExists,\n\tgapFill,\n\taverageMonthlyMap,\n\tfillMonthlyByMap,\n\tpad,\n\tannualAverage,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap\n} from \"./lib/Timeseries.fill\";\nimport {\n\tckmeans,\n\tmax,\n\tmedianAbsoluteDeviation,\n\tquantile\n} from \"simple-statistics\";\n\nimport {\n\trosnerTest,\n\tboxPlotTest,\n\tmodifiedZScoreTest\n} from \"./lib/Timeseries.statistics\";\nimport { annualScale, calculateChange } from \"./lib/misc\";\n\n// export default ;\n// Fill Options\nexport {\n\tTimeseries,\n\tannualAverage,\n\taverageMonthlyMap,\n\tannualMonthlyAverageMap,\n\tmonthlyRollingAverageMap,\n\tfillMonthlyBAnnualyMap,\n\tfillMonthlyByMap,\n\tpad\n};\nfunction Timeseries(data, options = {}) {\n\t// const { msIndex } = options;\n\tif (data instanceof Timeseries) {\n\t\treturn data;\n\t}\n\tif (data instanceof dataForge.DataFrame) {\n\t\tdata = data.toArray();\n\t}\n\n\tdata = data\n\t\t.map(({ date, ...others }) => ({ date: dayjs(date), ...others }))\n\t\t.sort((a, b) => a.date.valueOf() - b.date.valueOf());\n\tlet config = {\n\t\t// columns: ['date', 'value', 'raw', 'flag'],\n\t\tvalues: data,\n\t\tindex: data.map(({ date }) => date.toDate()),\n\t\tconsiderAllRows: true\n\t};\n\tdataForge.DataFrame.call(this, config);\n}\n\nTimeseries.prototype = Object.create(dataForge.DataFrame.prototype);\nTimeseries.prototype.constructor = Timeseries;\n\n// Getters\nfunction getValueColumns() {\n\treturn this.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray();\n}\nfunction interval() {\n\tconst computeInterval = window => window.last() - window.first();\n\tconst intervals = this.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => -row.Frequency);\n\t// .orderBy(row => row.Value);\n\n\tlet val = intervals.first().Value;\n\n\treturn msToInterval(val);\n}\n\nfunction dateRange(unit, adjustment) {\n\tlet start = dayjs(this.first().date),\n\t\tend = dayjs(this.last().date);\n\tif (adjustment) {\n\t\tstart = start.startOf(adjustment);\n\t\tend = end.endOf(adjustment);\n\t}\n\treturn end.diff(start, unit);\n}\nTimeseries.prototype.getValueColumns = getValueColumns;\nTimeseries.prototype.getInterval = interval;\nTimeseries.prototype.getDateRange = dateRange;\n\n// Statistics\nfunction cvrsme(actual, simulated) {\n\tlet df = this.subset([actual, simulated])\n\t\t.resetIndex()\n\t\t.generateSeries({\n\t\t\tactual: row => row[actual] || 0,\n\t\t\tsimulated: row => row[simulated] || 0\n\t\t})\n\t\t.dropSeries([actual, simulated])\n\t\t.generateSeries({ diff: row => row.actual - row.simulated });\n\tconsole.log(df.head(10).toString());\n\tlet n = df.count();\n\tlet p = 1.0;\n\tlet ybar = df.getSeries(actual).sum() / n;\n\tlet v = Math.sqrt(df.getSeries(\"diff\").sum() / (n - p)) / ybar;\n\treturn v;\n}\nfunction nmbe(actual, simulated) {\n\tlet df = this.subset([actual, simulated])\n\t\t.resetIndex()\n\t\t.generateSeries({\n\t\t\tactual: row => row[actual] || 0,\n\t\t\tsimulated: row => row[simulated] || 0\n\t\t})\n\t\t.dropSeries([actual, simulated])\n\t\t.generateSeries({ diff: row => row.actual - row.simulated });\n\tconsole.log(df.head(10).toString());\n\tlet n = df.count();\n\tlet p = 1.0;\n\tlet ybar = df.getSeries(\"actual\").sum() / n;\n\tconsole.log(n, p, ybar, df.getSeries(\"diff\").sum());\n\tlet b = df.getSeries(\"diff\").sum() / ((n - p) * ybar);\n\treturn b;\n}\nTimeseries.prototype.cvrsme = cvrsme;\nTimeseries.prototype.nmbe = nmbe;\n\n// Methods\nfunction calculateThresholdOptions({\n\tk,\n\tfilterZeros = true,\n\tfilterNegative = true\n} = {}) {\n\tlet noflags = this.where(\n\t\trow =>\n\t\t\trow.flag === null ||\n\t\t\trow.flag === undefined ||\n\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t)\n\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t.getSeries(\"value\");\n\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\tif (filterNegative) noflags = noflags.where(value => value > 0);\n\tif (!k) {\n\t\tk =\n\t\t\tnoflags.count() < 1000\n\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t}\n\tif (noflags.count() < 5) return {};\n\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\treturn { esd, box, modz };\n}\n\nfunction getBestThreshold() {\n\ttry {\n\t\tlet thresholds = this.calculateThresholdOptions();\n\t\tconst thresholdGroups = ckmeans(\n\t\t\t[\n\t\t\t\tget(thresholds, \"esd.upper\", null),\n\t\t\t\tget(thresholds, \"modz.upper\", null),\n\t\t\t\tget(thresholds, \"box.lowerOuter\", null),\n\t\t\t\tget(thresholds, \"box.upperOuter\", null)\n\t\t\t].filter(v => v),\n\t\t\t2\n\t\t);\n\t\tlet threshold_actual = max(\n\t\t\tthresholdGroups.reduce((a, b) => (a.length > b.length ? a : b))\n\t\t);\n\t\treturn threshold_actual;\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\tthrow new Error(\"Cannot determine threshold\");\n\t}\n}\n\nfunction calculateStatistics(options = {}) {\n\tconst {\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = options;\n\tlet series = this.deflate(row => row[column]).where(value => !isNaN(value));\n\tif (filterNegative) series = series.where(value => value >= 0);\n\tif (filterZeros) series = series.where(value => value !== 0);\n\tlet median = series.median();\n\tlet mean = series.average();\n\tlet count = series.count();\n\tlet std = series.std();\n\tlet min = series.min();\n\tlet max = series.max();\n\tlet mad = medianAbsoluteDeviation(series.toArray());\n\tlet q1 = quantile(series.toArray(), 0.25);\n\tlet q3 = quantile(series.toArray(), 0.75);\n\tlet iqr = q3 - q1;\n\tlet stats = {\n\t\tmedian,\n\t\tmean,\n\t\tcount,\n\t\tstd,\n\t\tmin,\n\t\tmax,\n\t\tmad,\n\t\tq1,\n\t\tq3,\n\t\tiqr\n\t};\n\treturn stats;\n}\n\nTimeseries.prototype.calculateStatistics = calculateStatistics;\nTimeseries.prototype.calculateThresholdOptions = calculateThresholdOptions;\nTimeseries.prototype.getBestThreshold = getBestThreshold;\n\n// Chainable Methods\nfunction betweenDates(start, end) {\n\tlet df = this.between(start, end);\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.betweenDates = betweenDates;\n\nfunction transformAllSeries(adjustmentFunction, { exclude }) {\n\tlet df = this;\n\tlet columns = (columns = df\n\t\t.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray());\n\tif (exclude && Array.isArray(exclude)) {\n\t\tcolumns = columns.filter(col => exclude.indexOf(col) === -1);\n\t}\n\tcolumns.forEach(col => {\n\t\tdf = df.transformSeries({\n\t\t\t[col]: value => {\n\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\treturn df;\n}\n\nTimeseries.prototype.transformAllSeries = transformAllSeries;\n\nfunction reset() {\n\tlet df = this.withSeries({\n\t\tvalue: row =>\n\t\t\trow.flag && Array.isArray(row.flag) && row.flag.length > 0\n\t\t\t\t? row.raw\n\t\t\t\t: row.value\n\t})\n\t\t.subset([\"date\", \"value\"])\n\t\t.where(row => !isNaN(row.value) && row.value !== null);\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.reset = reset;\n\nfunction group(interval, toArray) {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\tlet groups = this.groupBy(dateComparison);\n\treturn groups;\n}\n\nTimeseries.prototype.group = group;\n\nfunction removeOutliers({ series = \"value\", lower, upper } = {}) {\n\tif (lower > upper) throw new Error(\"thresholds invalid\");\n\tlet outlierCheck = (value, lower, upper) => value < lower || value > upper;\n\n\tlet outliers = this.where(row => outlierCheck(row[series], lower, upper))\n\t\t.generateSeries({\n\t\t\traw: row => row[series],\n\t\t\tflag: ({ flag = [] }) => [\"outlier\", ...flag]\n\t\t})\n\t\t.transformSeries({\n\t\t\t[series]: value => null\n\t\t});\n\n\tlet merged = this.merge(outliers);\n\treturn new Timeseries(merged);\n}\n\nTimeseries.prototype.removeOutliers = removeOutliers;\nTimeseries.prototype.clean = removeOutliers;\n\nfunction downsample([duration, value], fillType = \"sum\") {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t}\n\tlet dateComparison = row => row.date.startOf(duration);\n\tlet valueColumns = this.getValueColumns();\n\tif (value) {\n\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t}\n\tlet df = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\t...fromPairs([\n\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t}),\n\t\t\t\t\t...group\n\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => dayjs(row.date).toDate());\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.downsample = downsample;\n\nfunction upsample([duration, value], fillType = \"avg\") {\n\t// Dont use this b/c it has the raw and flag values\n\tlet df = this.fillGaps(\n\t\tgapExists([duration, value]),\n\t\tgapFill(fillType, [duration, value])\n\t);\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.upsample = upsample;\n\nfunction populate(value, type = \"avg\") {\n\tlet v;\n\tswitch (type) {\n\t\tcase \"fill\":\n\t\t\tv = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = value / this.count();\n\t\t\tbreak;\n\t}\n\tlet df = this.generateSeries({ value: row => v });\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.populate = populate;\n\nfunction reduceToValue(columnNames) {\n\tfunction chooseValue(row, columnNames = []) {\n\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\treturn values[0] || 0;\n\t}\n\tlet df = this.generateSeries({\n\t\tvalue: row => chooseValue(row, columnNames)\n\t}).subset([\"date\", \"value\"]);\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.reduceToValue = reduceToValue;\n\nfunction cumulativeSum(columns) {\n\tif (!columns) columns = this.getValueColumns();\n\tif (columns & !Array.isArray(columns)) columns = [columns];\n\tlet df = this;\n\tconsole.log(df.getColumnNames());\n\tconst cumulativeSum = sum => value => (sum += value);\n\tcolumns.forEach(s => {\n\t\tdf = df.withSeries(s, df.getSeries(s).select(cumulativeSum(0)));\n\t});\n\t// console.log(df.toString());\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.cumulativeSum = cumulativeSum;\n\nfunction totalRows(series = [\"value\"], colname = \"total\") {\n\tlet ndf = this.generateSeries({\n\t\t[colname]: row => series.map(v => row[v] || 0).reduce((a, b) => a + b, 0)\n\t});\n\treturn new Timeseries(ndf);\n}\nTimeseries.prototype.totalRows = totalRows;\nTimeseries.prototype.totalRow = totalRows;\nTimeseries.prototype.totalColumns = totalRows;\n\n// Baseline Functions\nfunction rollingPercentChange(col = \"value\", decimal = true) {\n\tlet df = this;\n\tlet delta = df.withSeries(\"delta\", df.getSeries(\"value\").percentChange());\n\tif (decimal) delta = data.transformSeries({ delta: value => value / 100 });\n\treturn new Timeseries(delta);\n}\n\nTimeseries.prototype.rollingPercentChange = rollingPercentChange;\nfunction baselinePercentChange(baselineDF) {\n\t// Only Change in Year\n\tif (!(baselineDF instanceof Timeseries))\n\t\tbaselineDF = new Timeseries(baselineDF);\n\tlet dfwb;\n\tif (baselineDF.count() > 1) {\n\t\tlet interval = this.getInterval();\n\t\tlet baselineInterval = baselineDF.interval;\n\t\tif (!isEqual(interval, baselineInterval)) {\n\t\t\tconsole.error(interval, baselineInterval);\n\t\t\tthrow new Error(\"baseline and data intervals do not match\");\n\t\t}\n\t\tlet indexer;\n\t\tswitch (interval[0]) {\n\t\t\tcase \"day\":\n\t\t\t\tindexer = date => `${date.month()}-${date.date()}`;\n\t\t\t\tbreak;\n\t\t\tcase \"month\":\n\t\t\t\tindexer = date => date.month();\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tindexer = date => 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet indexedBaseline = baselineDF.withIndex(row => indexer(row.date));\n\t\tlet getBaselineValue = index => {\n\t\t\tlet at = indexedBaseline.at(index);\n\t\t\tif (at && has(at, \"value\")) {\n\t\t\t\treturn at.value;\n\t\t\t} else {\n\t\t\t\treturn indexedBaseline.getSeries(\"value\").average();\n\t\t\t}\n\t\t};\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => getBaselineValue(indexer(row.date))\n\t\t});\n\t} else {\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => baselineDF.first().value\n\t\t});\n\t}\n\tdfwb = dfwb.generateSeries({\n\t\tdelta: row => calculateChange(row.baseline, row.value)\n\t});\n\treturn new Timeseries(dfwb);\n}\n\nTimeseries.prototype.baselinePercentChange = baselinePercentChange;\nTimeseries.prototype.addBaselineDelta = baselinePercentChange;\n\nfunction annualIntensity(normalizeValue = 1) {\n\tlet interval = this.getInterval();\n\tlet annual = this.groupBy(row => row.date.year())\n\t\t.select(group => {\n\t\t\tlet startDate = group.first().date;\n\t\t\tlet endDate = group\n\t\t\t\t.last()\n\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\treturn {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\t...fromPairs(\n\t\t\t\t\tthis.getValueColumns().map(col => [\n\t\t\t\t\t\tcol,\n\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.renameSeries({ startDate: \"date\" })\n\t\t.dropSeries(\"endDate\");\n\treturn new Timeseries(annual);\n}\n\nTimeseries.prototype.annualIntensity = annualIntensity;\n\n// Fill Functions\n\nfunction fillMissing() {\n\tlet df = this;\n\tlet startDate = df.first().date.toDate(),\n\t\tendDate = df.last().date.toDate();\n\tlet interval = df.getInterval();\n\tlet bdf = Timeseries.blank(\n\t\tstartDate,\n\t\tendDate,\n\t\tinterval,\n\t\t\"missing\"\n\t).withIndex(row => row.date.valueOf());\n\tlet m = bdf.merge(df.withIndex(row => row.date.valueOf())).generateSeries({\n\t\tflag: row =>\n\t\t\trow.value === null || row.value === undefined ? row.flag : undefined\n\t});\n\tm = new Timeseries(m);\n\treturn m;\n}\nTimeseries.prototype.fillMissing = fillMissing;\n\nfunction fillNull({ series = \"value\", value, callback }) {\n\tconst seriesCheck = row => row[series] === null || row[series] === undefined;\n\tif (callback) {\n\t\tlet df = this.generateSeries({\n\t\t\tflag: row =>\n\t\t\t\tseriesCheck(row) ? [\"fill\", ...(row.flag || [])] : row.flag,\n\t\t\t[series]: row => (seriesCheck(row) ? callback(row) : row[series])\n\t\t});\n\t\treturn new Timeseries(df);\n\t} else if (value) {\n\t\tlet df = this.generateSeries({\n\t\t\tflag: row => (seriesCheck(row) ? [\"fill\", ...(row.flag || [])] : row.flag)\n\t\t}).transformSeries({\n\t\t\t[series]: currentValue =>\n\t\t\t\tcurrentValue === null || currentValue === undefined\n\t\t\t\t\t? value\n\t\t\t\t\t: currentValue\n\t\t});\n\t\treturn new Timeseries(df);\n\t} else {\n\t\treturn this;\n\t}\n}\nTimeseries.prototype.fillNull = fillNull;\n\nfunction zeroFaultDetection(thresholdInterval) {\n\tif (!Array.isArray(thresholdInterval))\n\t\tthresholdInterval = [thresholdInterval, 1];\n\tthresholdInterval = intervalToMS(thresholdInterval);\n\tlet df = this;\n\tlet zeroFaultDates = df\n\t\t.where(row => row.value === 0)\n\t\t.ensureSeries(\n\t\t\t\"interval\",\n\t\t\tdf\n\t\t\t\t.where(row => row.value === 0)\n\t\t\t\t.getSeries(\"date\")\n\t\t\t\t.amountChange()\n\t\t)\n\t\t.where(v => v.interval <= thresholdInterval)\n\t\t.subset([\"date\"])\n\t\t.generateSeries({ value: row => null, flag: row => [\"zeroFault\"] });\n\n\tlet zeroFaultDF = new Timeseries(this.merge(zeroFaultDates));\n\treturn zeroFaultDF;\n}\n\nTimeseries.prototype.zeroFaultDetection = zeroFaultDetection;\n\nfunction dataQuality() {\n\tlet count = this.count();\n\tlet withFlags = this.where(r => Array.isArray(r.flag) && r.flag.length > 0)\n\t\t.groupBy(r => r.flag.toString())\n\t\t.select(group => ({\n\t\t\tflag: group.first().flag,\n\t\t\tcount: group.count(),\n\t\t\tpercent: group.count() / count\n\t\t}))\n\t\t.inflate();\n\tlet good = this.where(\n\t\tr =>\n\t\t\tr.flag === undefined ||\n\t\t\tr.flag === null ||\n\t\t\t(Array.isArray(r.flag) && r.flag.length === 0)\n\t).count();\n\tlet quality = withFlags\n\t\t.appendPair([\n\t\t\twithFlags.count(),\n\t\t\t{ flag: \"clean\", count: good, percent: good / count }\n\t\t])\n\t\t.orderByDescending(row => row.count);\n\treturn quality;\n}\n\nTimeseries.prototype.dataQuality = dataQuality;\n\nfunction monthlyWithQual() {\n\tlet interval = this.getInterval();\n\tlet ms = intervalToMS(interval);\n\tconst duration = \"month\";\n\tlet dateComparison = row =>\n\t\tdayjs(row.date)\n\t\t\t.startOf()\n\t\t\t.valueOf();\n\tlet ts = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t.startOf(duration)\n\t\t\t\t.toDate();\n\t\t\tlet fullCount = Math.floor(\n\t\t\t\tdayjs(date)\n\t\t\t\t\t.endOf(\"month\")\n\t\t\t\t\t.diff(dayjs(date), \"millisecond\") / ms\n\t\t\t);\n\t\t\tlet days = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n\t\t\tlet count = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => v && v !== 0)\n\t\t\t\t.toArray().length;\n\t\t\tlet value = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => !isNaN(v))\n\t\t\t\t.sum();\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\tvalue: isNaN(value) ? 0 : value,\n\t\t\t\tcount,\n\t\t\t\tfullCount,\n\t\t\t\tscore: count / fullCount\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => row.date.toDate());\n\treturn new Timeseries(ts);\n}\nTimeseries.prototype.monthlyWithQual = monthlyWithQual;\n\nfunction threeYearAverage(date, series = \"value\", defaultValue) {\n\tdate = dayjs(date);\n\tif (!defaultValue)\n\t\tdefaultValue = this.getSeries(series)\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\n\t// let months = df\n\t// \t.before(date.valueOf())\n\t// \t.where(row => dayjs(row.date).month() === date.month())\n\t// \t.where(row => row.score > 0.9)\n\t// \t.tail(3);\n\tlet months = this.before(date.toDate())\n\t\t.where(row => row.date.month() === date.month())\n\t\t.orderBy(row => dayjs(row.date))\n\t\t.tail(3);\n\t// .where(row => row.score > 0.9);\n\tif (months.count() > 0) {\n\t\tlet val = months\n\t\t\t.getSeries(series)\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\t\treturn val;\n\t} else {\n\t\treturn defaultValue;\n\t}\n}\nTimeseries.prototype.threeYearAverage = threeYearAverage;\n\nfunction averageFill() {\n\tlet df = this;\n\tlet avg = df\n\t\t// .where(row => row.score ?row.score >= 0.9)\n\t\t.getSeries(\"value\")\n\t\t.where(v => !isNaN(v) && v !== null)\n\t\t.average();\n\tlet monthlyAvg = df\n\t\t.generateSeries({\n\t\t\trollingAverage: row => df.threeYearAverage(row.date, \"value\", avg)\n\t\t})\n\t\t.generateSeries({\n\t\t\tflag: row => (row.value ? row.flag : [\"filled\", ...(row.flag || [])])\n\t\t})\n\t\t.generateSeries({\n\t\t\tvalue: row => (row.value ? row.value : row.rollingAverage)\n\t\t})\n\t\t.dropSeries([\"rollingAverage\"]);\n\treturn new Timeseries(monthlyAvg);\n}\n\nTimeseries.prototype.averageFill = averageFill;\n\n// Static Methods\nfunction blank(startDate, endDate, [duration, value = 1], flag) {\n\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\tconsole.error(interval);\n\t\tthrow new Error(\"interval type not supported\");\n\t}\n\tstartDate = dayjs(startDate);\n\tendDate = dayjs(endDate);\n\tlet dates = [startDate];\n\tlet interval = intervalToMS([duration, value]);\n\twhile (dates[dates.length - 1].valueOf() < endDate.valueOf()) {\n\t\tdates.push(dayjs(dates[dates.length - 1]).add(value, duration));\n\t}\n\tlet df = new Timeseries(dates.map(date => ({ date })));\n\n\tif (flag) {\n\t\tdf = new Timeseries(\n\t\t\tdf.generateSeries({\n\t\t\t\tflag: row => [flag]\n\t\t\t})\n\t\t);\n\t}\n\n\treturn df;\n}\nTimeseries.blank = blank;\nfunction aggregate(dataframes) {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df));\n\tconst valueColumns = new Set(\n\t\tdataframes.map(df => df.getValueColumns()).reduce((a, b) => a.concat(b), [])\n\t);\n\tconst concatenated = dataForge.DataFrame.concat(dataframes)\n\t\t.groupBy(row => row.date)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date;\n\t\t\tlet o = { date };\n\t\t\tvalueColumns.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\tgroup\n\t\t\t\t.getColumnNames()\n\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t.filter(col => valueColumns.has(col) === -1)\n\t\t\t\t.forEach(col => {\n\t\t\t\t\tlet value = group\n\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t.toArray();\n\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\to[col] = value;\n\t\t\t\t\treturn;\n\t\t\t\t});\n\t\t\treturn o;\n\t\t})\n\t\t.inflate();\n\treturn new Timeseries(concatenated);\n}\n\nTimeseries.aggregate = aggregate;\nTimeseries.concat = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df =>\n\t\tnew Timeseries(df).withIndex(row => row.date.valueOf())\n\t);\n\tlet df = dataForge.DataFrame.concat(dataframes);\n\treturn new Timeseries(df);\n};\nTimeseries.merge = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df =>\n\t\tnew Timeseries(df).withIndex(row => row.date.valueOf())\n\t);\n\tlet df = dataForge.DataFrame.merge(dataframes);\n\treturn new Timeseries(df);\n};\n"],"names":["intervalToMS","unit","value","start","dayjs","add","diff","valueFiller","fillType","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","averageMonthlyMap","df","Map","group","select","month","first","getSeries","where","v","average","toArray","rval","values","deflate","row","x","std","sampleStandardDeviation","mean","_mean","ndf","generateSeries","ares","R","DataFrame","Math","abs","max","lambdaTest","n","i","alpha","p","pValue","t","degreeOfFreedom","Studentt","inv","tValue","lambda","sqrt","pow","modz","mad","median","modifiedZScoreTest","_median","medianAbsoluteDeviation","outliers","sort","a","b","filter","thresholds","upper","min","Infinity","lower","calculateChange","baseline","Timeseries","data","options","dataForge","config","others","valueOf","index","toDate","considerAllRows","call","this","removeOutliers","series","outlierCheck","raw","transformSeries","merge","totalRows","colname","reduce","baselinePercentChange","baselineDF","dfwb","count","indexer","interval","getInterval","baselineInterval","isEqual","console","error","indexedBaseline","withIndex","at","has","delta","prototype","Object","create","constructor","getValueColumns","detectTypes","Type","distinct","Column","ms","end","getIndex","window","last","detectValues","orderBy","Frequency","Value","ceil","getDateRange","adjustment","startOf","endOf","cvrsme","actual","simulated","subset","resetIndex","dropSeries","log","head","toString","ybar","sum","nmbe","calculateStatistics","column","filterZeros","filterNegative","isNaN","q1","quantile","q3","iqr","calculateThresholdOptions","k","noflags","Array","isArray","length","floor","esd","dataset","newdf","dataframe","trip","pair","assign","push","outlierValues","outlier","takeWhile","iterations","rosnerTest","box","lowerInner","upperInner","lowerOuter","upperOuter","getBestThreshold","thresholdGroups","ckmeans","get","betweenDates","between","transformAllSeries","adjustmentFunction","exclude","columns","col","forEach","reset","withSeries","groupBy","clean","downsample","duration","dateComparison","valueColumns","getColumnNames","inflate","upsample","fillGaps","durationValue","pairA","pairB","startDate","gapExists","endDate","newEntries","e","gapFill","populate","type","reduceToValue","columnNames","chooseValue","cumulativeSum","s","totalRow","totalColumns","rollingPercentChange","decimal","percentChange","addBaselineDelta","annualIntensity","normalizeValue","year","scaler","_this","renameSeries","fillMissing","m","blank","undefined","fillNull","callback","seriesCheck","currentValue","zeroFaultDetection","thresholdInterval","zeroFaultDates","ensureSeries","amountChange","dataQuality","withFlags","r","percent","good","appendPair","orderByDescending","monthlyWithQual","fullCount","Date","getFullYear","getMonth","getDate","score","threeYearAverage","defaultValue","months","before","tail","averageFill","avg","rollingAverage","dates","aggregate","dataframes","Set","concat","o","c","years","after","subtract","bake","hour","minute","ts","set","annualMonthlyMap","monthMap","rollingWindow"],"mappings":"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"}
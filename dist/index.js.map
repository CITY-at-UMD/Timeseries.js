{"version":3,"file":"index.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n  let start = dayjs();\n  let end = dayjs().add(ms);\n  if (end.diff(start, \"year\", true) >= 1) {\n    return [\"year\", end.diff(start, \"year\")];\n  } else if (end.diff(start, \"month\", true) >= 1) {\n    return [\"month\", end.diff(start, \"month\")];\n  } else if (end.diff(start, \"day\", true) >= 1) {\n    return [\"day\", end.diff(start, \"day\")];\n  } else if (end.diff(start, \"hour\", true) >= 1) {\n    return [\"hour\", end.diff(start, \"hour\")];\n  } else {\n    return [\"minute\", end.diff(start, \"minute\")];\n  }\n};\n\nfunction calculateInterval(df, startDate, endDate) {\n  if (!startDate) startDate = df.first.date;\n  if (!endDate) endDate = df.last.date;\n  function computeInterval(window) {\n    return window.last() - window.first();\n  }\n  const intervals = df\n    .between(startDate, endDate)\n    .getIndex()\n    .window(2)\n    .select(computeInterval)\n    .detectValues()\n    .orderBy(row => row.Frequency);\n\n  let val = intervals.last().Value;\n  return msToInterval(val);\n}\nexport { msToInterval, calculateInterval };\n","import dayjs from \"dayjs\";\nimport _ from \"lodash\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration, true) /\n      durationValue\n  );\n\n  if (gapSize > 0) return true;\n  return false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize;\n  if (interval === \"quarterHour\") {\n    gapSize = Math.floor(\n      dayjs(endDate).diff(startDate, \"minutes\") / 15\n    );\n  } else {\n    gapSize = dayjs(endDate).diff(startDate, interval);\n  }\n  if (maxGap && maxGap > gapSize) return false;\n  if (gapSize > 0) return true;\n  return false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const newEntries = [];\n\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let date = dayjs(startDate)\n      .add((entryIndex + 1) * durationValue, duration)\n      .toDate();\n    newEntries.push([\n      date.valueOf(),\n      { date, value: null, ...(flag && { flag: [flag] }) }\n    ]);\n  }\n  return newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n  fillType,\n  { startValue, endValue, entryIndex, numEntries },\n  { overrideValue, dateFunction, date, flag }\n) => {\n  if (\n    [\n      \"pad\",\n      \"interpolate\",\n      \"average\",\n      \"dateFunction\",\n      \"value\"\n    ].indexOf(fillType) === -1\n  ) {\n    throw new Error(\"fill Type not supported\");\n  }\n  let value;\n  if (fillType === \"pad\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, startValue[key]];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", \"pad\"];\n  } else if (fillType === \"interpolate\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv =\n          startValue[key] +\n          (entryIndex + 1) *\n            ((endValue[key] - startValue[key]) /\n              (numEntries + 1));\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"average\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = (startValue[key] + endValue[key]) / numEntries;\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"dateFunction\" && dateFunction) {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = dateFunction(date);\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"value\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv;\n        if (typeof overrideValue === \"number\") {\n          nv = overrideValue;\n        } else {\n          nv = overrideValue[key];\n        }\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, null];\n      })\n    );\n    flag = [\"fill\"];\n  }\n  return { ...value, flag };\n};\n\nconst gapFill = (\n  fillType,\n  [duration, durationValue],\n  { overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n  // Fill values forward.\n\n  const startDate = dayjs(pairA[0]);\n  const endDate = dayjs(pairB[0]);\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const startValue = pairA[1];\n  const endValue = pairB[1];\n  const newEntries = [];\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let adjustment = valueFiller(\n        fillType,\n        { startValue, endValue, entryIndex, numEntries },\n        {\n          overrideValue,\n          dateFunction,\n          flag\n        }\n      ),\n      date = dayjs(startDate)\n        .add((entryIndex + 1) * durationValue, duration)\n        .toDate();\n    let e = [\n      date.valueOf(),\n      Object.assign({}, adjustment, { date })\n    ];\n    newEntries.push(e);\n  }\n\n  return newEntries;\n};\n\nexport {\n  gapExists,\n  gapFill,\n  gapFillBlank,\n  gapFillNull,\n  valueFiller\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\n\nclass Timeseries extends DataFrame {\n\tconstructor(data = []) {\n\t\tif (data instanceof DataFrame || data instanceof Timeseries) {\n\t\t\tdata = data.toArray();\n\t\t}\n\t\t// sort\n\t\tdata = data.sort(\n\t\t\t(a, b) => new Date(a.date).valueOf() - new Date(b.date).valueOf()\n\t\t);\n\t\tlet config = {\n\t\t\tvalues: data,\n\t\t\tindex: data.map(({ date }) => new Date(date).valueOf()),\n\t\t\tconsiderAllRows: true\n\t\t};\n\t\tsuper(config);\n\t}\n\tget interval() {\n\t\tlet startDate = this.first().date;\n\t\tlet endDate = this.last().date;\n\t\tfunction computeInterval(window) {\n\t\t\treturn window.last() - window.first();\n\t\t}\n\t\tconst intervals = this.between(startDate, endDate)\n\t\t\t.getIndex()\n\t\t\t.window(2)\n\t\t\t.select(computeInterval)\n\t\t\t.detectValues()\n\t\t\t.orderBy(row => row.Frequency)\n\t\t\t.orderBy(row => row.Value);\n\t\tlet val = intervals.last().Value;\n\t\treturn msToInterval(val);\n\t}\n\tdateRange(unit, adjustment) {\n\t\tlet start = dayjs(this.first().date),\n\t\t\tend = dayjs(this.last().date);\n\t\tif (adjustment) {\n\t\t\tstart = start.startOf(adjustment);\n\t\t\tend = end.endOf(adjustment);\n\t\t}\n\t\treturn end.diff(start, unit);\n\t}\n\tat(date) {\n\t\treturn super.at(new Date(date).valueOf());\n\t}\n\tcalculateThresholds({ k, filterZeros = true } = {}) {\n\t\tlet noflags = this.where(\n\t\t\trow =>\n\t\t\t\trow.flag === null ||\n\t\t\t\trow.flag === undefined ||\n\t\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t\t)\n\t\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t\t.getSeries(\"value\");\n\t\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\t\tif (!k) {\n\t\t\tk =\n\t\t\t\tnoflags.count() < 1000\n\t\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t\t}\n\t\tif (noflags.count() < 5) return {};\n\t\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\t\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\t\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\t\treturn { esd, box, modz };\n\t}\n\tremoveOutliers({ lowerThreshold, upperThreshold } = {}) {\n\t\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\t\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\t\tvalue < lowerThreshold || value > upperThreshold;\n\t\tlet df = this.generateSeries({\n\t\t\traw: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? row.value\n\t\t\t\t\t: null,\n\t\t\tflag: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? [\"outlier\"]\n\t\t\t\t\t: null\n\t\t}).transformSeries({\n\t\t\tvalue: value =>\n\t\t\t\toutlierCheck(value, lowerThreshold, upperThreshold) ? null : value\n\t\t});\n\t\treturn df;\n\t}\n\treset() {\n\t\treturn this.withSeries({\n\t\t\tvalue: row => (row.raw && !isNaN(row.raw) ? row.raw : row.value)\n\t\t}).dropSeries([\"flag\", \"raw\"]);\n\t}\n\tgroup(interval, toArray) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\t\tlet groups = this.groupBy(dateComparison);\n\t\treturn groups;\n\t}\n\t// Not Working Yet, downsample and upsample independently work\n\tresample([duration, value = 1], fillType) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet interval = this.interval;\n\t\tif (isEqual(interval, [duration, value])) {\n\t\t\treturn this;\n\t\t}\n\t\tlet d0 = dayjs(0);\n\t\tlet currentSampleDiff = dayjs(0)\n\t\t\t.add(interval[1], interval[0])\n\t\t\t.diff(d0);\n\t\tlet newSampleDiff = dayjs(0)\n\t\t\t.add(value, duration)\n\t\t\t.diff(d0);\n\t\tif (currentSampleDiff < newSampleDiff) {\n\t\t\treturn this.downsample([duration, value], fillType);\n\t\t} else {\n\t\t\treturn this.upsample([duration, value], fillType);\n\t\t}\n\t}\n\tupsample([duration, value], fillType = \"avg\") {\n\t\t// Dont use this b/c it has the raw and flag values\n\t\tlet df = this.fillGaps(\n\t\t\tgapExists([duration, value]),\n\t\t\tgapFill(fillType, [duration, value])\n\t\t);\n\t\treturn df;\n\t}\n\tdownsample([duration, value], fillType = \"sum\") {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t\t}\n\t\tlet dateComparison = row => dayjs(row.date).startOf(duration);\n\t\tif (value)\n\t\t\tdateComparison = row =>\n\t\t\t\tdayjs(row.date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.add(value, duration);\n\t\tlet df = this.groupBy(dateComparison)\n\t\t\t.select(group => {\n\t\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.toDate();\n\t\t\t\treturn {\n\t\t\t\t\tdate,\n\t\t\t\t\t...fromPairs(\n\t\t\t\t\t\tgroup\n\t\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).median();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).average();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).sum();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.withIndex(row => row.date.valueOf());\n\t\treturn df;\n\t}\n\tcalculateStatistics({\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = {}) {\n\t\tlet series = this.deflate(row => row[columnName]).where(\n\t\t\tvalue => !isNaN(value)\n\t\t);\n\t\tif (filterNegative) series = series.where(value => value >= 0);\n\t\tif (filterZeros) series = series.where(value => value !== 0);\n\t\tlet median = series.median();\n\t\tlet mean = series.average();\n\t\tlet count = series.count();\n\t\tlet std = series.std();\n\t\tlet min = series.min();\n\t\tlet max = series.max();\n\t\tlet mad = medianAbsoluteDeviation(series.toArray());\n\t\tlet q1 = quantile(series.toArray(), 0.25);\n\t\tlet q3 = quantile(series.toArray(), 0.75);\n\t\tlet iqr = q3 - q1;\n\t\tlet stats = {\n\t\t\tmedian,\n\t\t\tmean,\n\t\t\tcount,\n\t\t\tstd,\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tmad,\n\t\t\tq1,\n\t\t\tq3,\n\t\t\tiqr\n\t\t};\n\t\treturn stats;\n\t}\n\tdataQuality() {\n\t\tlet count = this.count();\n\t\tlet valid = this.getSeries(\"flag\")\n\t\t\t.where(\n\t\t\t\tvalue =>\n\t\t\t\t\tvalue === null ||\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t)\n\t\t\t.count();\n\t\tlet missing = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"missing\") !== -1)\n\t\t\t.count();\n\t\tlet invalid = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"outlier\") !== -1)\n\t\t\t.count();\n\t\tlet zeroFill = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"zeroFill\") !== -1)\n\t\t\t.count();\n\t\tlet breakdown = {\n\t\t\tvalid: valid / count,\n\t\t\tmissing: missing / count,\n\t\t\tinvalid: invalid / count\n\t\t};\n\t\tlet report = {\n\t\t\taccuracy: 0,\n\t\t\tcompleteness: 0,\n\t\t\tconsistency: 0\n\t\t};\n\t\treturn {};\n\t}\n\tpopulate(value, type = \"avg\") {\n\t\tlet v;\n\t\tswitch (type) {\n\t\t\tcase \"fill\":\n\t\t\t\tv = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = value / this.getIndex().count();\n\t\t\t\tbreak;\n\t\t}\n\t\tlet df = this.generateSeries({ value: row => v });\n\t\treturn df;\n\t}\n\tfill(interval, fillType) {\n\t\t// let interval = this.interval;\n\t\tif (!interval || !Array.isArray(interval)) interval = this.interval;\n\t\tlet ndf = this.fillGaps(gapExists(interval), gapFill(fillType, interval));\n\t\treturn new Timeseries(ndf);\n\t}\n\treduceToValue(columnNames) {\n\t\tfunction chooseValue(row, columnNames = []) {\n\t\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\t\treturn values[0] || 0;\n\t\t}\n\t\tlet df = this.generateSeries({\n\t\t\tvalue: row => chooseValue(row, columnNames)\n\t\t}).subset([\"date\", \"value\"]);\n\t\treturn new Timeseries(df);\n\t}\n\tclean(columnName = \"value\", { lowerThreshold, upperThreshold }) {\n\t\tlet arr = this.toArray().map(row => {\n\t\t\tlet value = row[columnName];\n\t\t\tif (value > upperThreshold || value < lowerThreshold) {\n\t\t\t\treturn { ...row, value: undefined, raw: value };\n\t\t\t} else {\n\t\t\t\treturn row;\n\t\t\t}\n\t\t});\n\t\treturn new Timeseries(arr);\n\t}\n\tstatic blank(startDate, endDate, [duration, value = 1]) {\n\t\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\t\tconsole.error(interval);\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\t}\n\t\tlet df = new Timeseries([\n\t\t\t{ date: new Date(startDate) },\n\t\t\t{ date: new Date(endDate) }\n\t\t])\n\t\t\t.fillGaps(gapExists([duration, value]), gapFillBlank([duration, value]))\n\t\t\t.between(startDate, endDate);\n\t\treturn new Timeseries(df);\n\t}\n\tstatic aggregate(dataframes) {\n\t\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\t\tdataframes = dataframes.map(df => new Timeseries(df));\n\t\tconst concatenated = DataFrame.concat(dataframes)\n\t\t\t.groupBy(row => row.date)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date;\n\t\t\t\tlet o = { date };\n\t\t\t\tgroup\n\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t.filter(c => c !== \"date\")\n\t\t\t\t\t.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\t\treturn o;\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.toArray();\n\t\treturn new Timeseries(concatenated);\n\t}\n\t// Models\n\tannualMonthlyAverage({ startDate, endDate }) {\n\t\tlet months = this.downsample([\"month\", 1], \"sum\").between(\n\t\t\tstartDate,\n\t\t\tendDate\n\t\t);\n\t\tlet avg = months.getSeries(\"value\").average();\n\t}\n}\nexport default Timeseries;\n"],"names":["gapExists","duration","durationValue","pairA","pairB","startDate","Math","floor","dayjs","diff","valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","gapFill","endDate","newEntries","adjustment","add","toDate","e","valueOf","Object","assign","push","data","DataFrame","Timeseries","toArray","config","values","sort","a","b","Date","index","considerAllRows","dateRange","unit","start","this","first","end","last","startOf","endOf","at","calculateThresholds","k","filterZeros","noflags","where","row","Array","isArray","length","isNaN","getSeries","count","min","esd","rosnerTest","thresholds","box","boxPlotTest","modz","modifiedZScoreTest","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","generateSeries","raw","transformSeries","reset","withSeries","dropSeries","group","interval","groupBy","resample","isEqual","d0","downsample","upsample","fillGaps","dateComparison","select","getColumnNames","filter","col","deflate","median","average","sum","inflate","withIndex","calculateStatistics","filterNegative","series","columnName","mean","std","max","mad","medianAbsoluteDeviation","q1","quantile","q3","iqr","dataQuality","populate","type","v","getIndex","fill","reduceToValue","columnNames","n","chooseValue","subset","clean","undefined","blank","console","error","df","gapFillBlank","between","aggregate","dataframes","concat","o","c","forEach","annualMonthlyAverage","ms","window","detectValues","orderBy","Frequency","Value"],"mappings":"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"}
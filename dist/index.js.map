{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const { DataFrame } = require(\"data-forge\");\nconst dayjs = require(\"dayjs\");\n// const isBetween = require('dayjs/plugin/isBetween')\nconst { msToInterval } = require(\"./lib/Timeseries.interval\");\nconst isEqual = require(\"lodash/isEqual\");\nconst fromPairs = require(\"lodash/fromPairs\");\nconst {\n  gapExists,\n  gapFill,\n  gapFillBlank\n} = require(\"./lib/Timeseries.fill\");\nconst {\n  medianAbsoluteDeviation,\n  quantile\n} = require(\"simple-statistics\");\nclass Timeseries extends DataFrame {\n  constructor(data = []) {\n    if (\n      data instanceof DataFrame ||\n      data instanceof Timeseries\n    ) {\n      data = data.toArray();\n    }\n    // sort\n    data = data.sort(\n      (a, b) =>\n        new Date(a.date).valueOf() - new Date(b.date).valueOf()\n    );\n    let config = {\n      values: data,\n      index: data.map(({ date }) => new Date(date).valueOf()),\n      considerAllRows: true\n    };\n    super(config);\n  }\n  get interval() {\n    let startDate = this.first().date;\n    let endDate = this.last().date;\n    function computeInterval(window) {\n      return window.last() - window.first();\n    }\n    const intervals = this.between(startDate, endDate)\n      .getIndex()\n      .window(2)\n      .select(computeInterval)\n      .detectValues()\n      .orderBy(row => row.Frequency)\n      .orderBy(row => row.Value);\n    let val = intervals.last().Value;\n    return msToInterval(val);\n  }\n  dateRange(unit, adjustment) {\n    let start = dayjs(this.first().date),\n      end = dayjs(this.last().date);\n    if (adjustment) {\n      start = start.startOf(adjustment);\n      end = end.endOf(adjustment);\n    }\n    return end.diff(start, unit);\n  }\n  at(date) {\n    return super.at(new Date(date).valueOf());\n  }\n  calculateThresholds({ k, filterZeros = true } = {}) {\n    let noflags = this.where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        (Array.isArray(row.flag) && row.flag.length === 0)\n    )\n      .where(row => !isNaN(row.value) && row.value !== null)\n      .getSeries(\"value\");\n    if (filterZeros)\n      noflags = noflags.where(value => value !== 0);\n    if (!k) {\n      k =\n        noflags.count() < 1000\n          ? Math.floor(noflags.count() * 0.15)\n          : Math.min(\n              ...[1000, Math.floor(noflags.count() * 0.02)]\n            );\n    }\n    if (noflags.count() < 5) return {};\n    let { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n    let { thresholds: box } = boxPlotTest(noflags.toArray());\n    let { thresholds: modz } = modifiedZScoreTest(\n      noflags.toArray()\n    );\n    return { esd, box, modz };\n  }\n  removeOutliers({ lowerThreshold, upperThreshold } = {}) {\n    if (lowerThreshold > upperThreshold)\n      throw new Error(\"thresholds invalid\");\n    let outlierCheck = (value, lowerThreshold, upperThreshold) =>\n      value < lowerThreshold || value > upperThreshold;\n    let df = this.generateSeries({\n      raw: row =>\n        outlierCheck(row.value, lowerThreshold, upperThreshold)\n          ? row.value\n          : null,\n      flag: row =>\n        outlierCheck(row.value, lowerThreshold, upperThreshold)\n          ? [\"outlier\"]\n          : null\n    }).transformSeries({\n      value: value =>\n        outlierCheck(value, lowerThreshold, upperThreshold)\n          ? null\n          : value\n    });\n    return df;\n  }\n  reset() {\n    return this.withSeries({\n      value: row =>\n        row.raw && !isNaN(row.raw) ? row.raw : row.value\n    }).dropSeries([\"flag\", \"raw\"]);\n  }\n  group(interval, toArray) {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    let dateComparison = row =>\n      dayjs(row.date).startOf(interval);\n    let groups = this.groupBy(dateComparison);\n    return groups;\n  }\n  // Not Working Yet, downsample and upsample independently work\n  resample([duration, value = 1], fillType) {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    let interval = this.interval;\n    if (isEqual(interval, [duration, value])) {\n      return this;\n    }\n    let d0 = dayjs(0);\n    let currentSampleDiff = dayjs(0)\n      .add(interval[1], interval[0])\n      .diff(d0);\n    let newSampleDiff = dayjs(0)\n      .add(value, duration)\n      .diff(d0);\n    console.log(currentSampleDiff, newSampleDiff);\n    if (currentSampleDiff < newSampleDiff) {\n      console.log(\"downsample\");\n      return this.downsample([duration, value], fillType);\n    } else {\n      console.log(\"upsample\");\n      return this.upsample([duration, value], fillType);\n    }\n  }\n  upsample([duration, value], fillType = \"avg\") {\n    // Dont use this b/c it has the raw and flag values\n    let df = this.fillGaps(\n      gapExists([duration, value]),\n      gapFill(fillType, [duration, value])\n    );\n    return df;\n  }\n  downsample([duration, value], fillType = \"sum\") {\n    if (\n      [\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1\n    )\n      throw new Error(\"interval type not supported\");\n    if ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n      throw new Error(\"aggregation type not suppported, only:\");\n    }\n    let dateComparison = row =>\n      dayjs(row.date).startOf(duration);\n    if (value)\n      dateComparison = row =>\n        dayjs(row.date)\n          .startOf(duration)\n          .add(value, duration);\n    let df = this.groupBy(dateComparison)\n      .select(group => {\n        const date = dayjs(group.first().date)\n          .startOf(duration)\n          .toDate();\n        return {\n          date,\n          ...fromPairs(\n            group\n              .getColumnNames()\n              .filter(col => col !== \"date\")\n              .map(col => {\n                let value;\n                switch (fillType) {\n                  case \"median\":\n                    value = group\n                      .deflate(row => row[col])\n                      .median();\n                    break;\n                  case \"avg\":\n                    value = group\n                      .deflate(row => row[col])\n                      .average();\n                    break;\n                  default:\n                    // sum\n                    value = group.deflate(row => row[col]).sum();\n                    break;\n                }\n                return [col, value];\n              })\n          )\n        };\n      })\n      .inflate()\n      .withIndex(row => row.date.valueOf());\n    return df;\n  }\n  calculateStatistics({\n    column = \"value\",\n    filterZeros = false,\n    filterNegative = true\n  } = {}) {\n    let series = this.deflate(row => row[columnName]).where(\n      value => !isNaN(value)\n    );\n    if (filterNegative)\n      series = series.where(value => value >= 0);\n    if (filterZeros) series = series.where(value => value !== 0);\n    let median = series.median();\n    let mean = series.average();\n    let count = series.count();\n    let std = series.std();\n    let min = series.min();\n    let max = series.max();\n    let mad = medianAbsoluteDeviation(series.toArray());\n    let q1 = quantile(series.toArray(), 0.25);\n    let q3 = quantile(series.toArray(), 0.75);\n    let iqr = q3 - q1;\n    let stats = {\n      median,\n      mean,\n      count,\n      std,\n      min,\n      max,\n      mad,\n      q1,\n      q3,\n      iqr\n    };\n    return stats;\n  }\n  dataQuality() {\n    let count = this.count();\n    let valid = this.getSeries(\"flag\")\n      .where(\n        value =>\n          value === null ||\n          value === undefined ||\n          (Array.isArray(value) && value.length === 0)\n      )\n      .count();\n    let missing = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"missing\") !== -1)\n      .count();\n    let invalid = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"outlier\") !== -1)\n      .count();\n    let zeroFill = this.getSeries(\"flag\")\n      .where(value => Array.isArray(value))\n      .where(value => value.indexOf(\"zeroFill\") !== -1)\n      .count();\n    let breakdown = {\n      valid: valid / count,\n      missing: missing / count,\n      invalid: invalid / count\n    };\n    let report = {\n      accuracy: 0,\n      completeness: 0,\n      consistency: 0\n    };\n    return {};\n  }\n  populate(value, type = \"avg\") {\n    let v;\n    switch (type) {\n      case \"fill\":\n        v = value;\n        break;\n      default:\n        v = value / this.getIndex().count();\n        break;\n    }\n    let df = this.generateSeries({ value: row => v });\n    return df;\n  }\n  static blank(startDate, endDate, [duration, value = 1]) {\n    if (\n      [\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(\n        duration\n      ) < 0\n    ) {\n      console.error(interval);\n      throw new Error(\"interval type not supported\");\n    }\n    let df = new Timeseries([\n      { date: new Date(startDate) },\n      { date: new Date(endDate) }\n    ])\n      .fillGaps(\n        gapExists([duration, value]),\n        gapFillBlank([duration, value])\n      )\n      .between(startDate, endDate);\n    console.log(df instanceof Timeseries);\n    console.log(df instanceof DataFrame);\n    return new Timeseries(df);\n  }\n  static aggregate(dataframes) {\n    if (!Array.isArray(dataframes)) dataframes = [dataframes];\n    dataframes = dataframes.map(df => new Timeseries(df));\n    const concatenated = DataFrame.concat(dataframes)\n      .groupBy(row => row.date)\n      .select(group => {\n        const date = group.first().date;\n        let o = { date };\n        group\n          .getColumnNames()\n          .filter(c => c !== \"date\")\n          .forEach(\n            c => (o[c] = group.deflate(row => row[c]).sum())\n          );\n        return o;\n      })\n      .inflate()\n      .toArray();\n    return new Timeseries(concatenated);\n  }\n}\nmodule.exports = Timeseries;\n"],"names":["DataFrame","require","dayjs","msToInterval","isEqual","fromPairs","gapExists","gapFill","gapFillBlank","medianAbsoluteDeviation","quantile","module","exports","data","Timeseries","toArray","config","values","sort","a","b","Date","date","valueOf","index","map","considerAllRows","dateRange","unit","adjustment","start","this","first","end","last","startOf","endOf","diff","at","calculateThresholds","k","filterZeros","noflags","where","row","flag","Array","isArray","length","isNaN","value","getSeries","count","Math","floor","min","esd","rosnerTest","thresholds","box","boxPlotTest","modz","modifiedZScoreTest","removeOutliers","lowerThreshold","upperThreshold","Error","outlierCheck","generateSeries","raw","transformSeries","reset","withSeries","dropSeries","group","interval","indexOf","groupBy","resample","fillType","duration","d0","currentSampleDiff","add","newSampleDiff","console","log","downsample","upsample","fillGaps","dateComparison","select","toDate","getColumnNames","filter","col","deflate","median","average","sum","inflate","withIndex","calculateStatistics","filterNegative","series","columnName","mean","std","max","mad","q1","q3","iqr","dataQuality","populate","type","v","getIndex","blank","startDate","endDate","error","df","between","aggregate","dataframes","concat","o","c","forEach","val","window","detectValues","orderBy","Frequency","Value"],"mappings":"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"}
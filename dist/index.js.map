{"version":3,"file":"index.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/lib/Timeseries.statistics.js","../src/index.js","../src/lib/misc.js","../src/lib/Timeseries.zero.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\nconst intervalToMS = ([unit, value]) => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(value, unit);\n\treturn end.diff(start);\n};\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, intervalToMS, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration, true) / durationValue\n\t);\n\n\tif (gapSize > 0) return true;\n\treturn false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize;\n\tif (interval === \"quarterHour\") {\n\t\tgapSize = Math.floor(dayjs(endDate).diff(startDate, \"minutes\") / 15);\n\t} else {\n\t\tgapSize = dayjs(endDate).diff(startDate, interval);\n\t}\n\tif (maxGap && maxGap > gapSize) return false;\n\tif (gapSize > 0) return true;\n\treturn false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst newEntries = [];\n\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet date = dayjs(startDate).add((entryIndex + 1) * durationValue, duration);\n\t\tnewEntries.push([\n\t\t\tdate.valueOf(),\n\t\t\t{ date, value: undefined, ...(flag && { flag: [flag] }) }\n\t\t]);\n\t}\n\treturn newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n\tfillType,\n\t{ startValue, endValue, entryIndex, numEntries },\n\t{ overrideValue, dateFunction, date, flag }\n) => {\n\tif (\n\t\t[\"pad\", \"interpolate\", \"average\", \"dateFunction\", \"value\"].indexOf(\n\t\t\tfillType\n\t\t) === -1\n\t) {\n\t\tthrow new Error(\"fill Type not supported\");\n\t}\n\tlet value;\n\tif (fillType === \"pad\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, startValue[key]];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", \"pad\"];\n\t} else if (fillType === \"interpolate\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv =\n\t\t\t\t\tstartValue[key] +\n\t\t\t\t\t(entryIndex + 1) *\n\t\t\t\t\t\t((endValue[key] - startValue[key]) / (numEntries + 1));\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"average\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = (startValue[key] + endValue[key]) / numEntries;\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"dateFunction\" && dateFunction) {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = dateFunction(date);\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"value\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv;\n\t\t\t\tif (typeof overrideValue === \"number\") {\n\t\t\t\t\tnv = overrideValue;\n\t\t\t\t} else {\n\t\t\t\t\tnv = overrideValue[key];\n\t\t\t\t}\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, null];\n\t\t\t})\n\t\t);\n\t\tflag = [\"fill\"];\n\t}\n\treturn { ...value, flag };\n};\n\nconst gapFill = (\n\tfillType,\n\t[duration, durationValue],\n\t{ overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n\t// Fill values forward.\n\n\tconst startDate = dayjs(pairA[0]);\n\tconst endDate = dayjs(pairB[0]);\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst startValue = pairA[1];\n\tconst endValue = pairB[1];\n\tconst newEntries = [];\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet adjustment = valueFiller(\n\t\t\t\tfillType,\n\t\t\t\t{ startValue, endValue, entryIndex, numEntries },\n\t\t\t\t{\n\t\t\t\t\toverrideValue,\n\t\t\t\t\tdateFunction,\n\t\t\t\t\tflag\n\t\t\t\t}\n\t\t\t),\n\t\t\tdate = dayjs(startDate)\n\t\t\t\t.add((entryIndex + 1) * durationValue, duration)\n\t\t\t\t.toDate();\n\t\tlet e = [date.valueOf(), Object.assign({}, adjustment, { date })];\n\t\tnewEntries.push(e);\n\t}\n\n\treturn newEntries;\n};\n\nexport { gapExists, gapFill, gapFillBlank, gapFillNull, valueFiller };\n","// Source: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm\n// https://vsp.pnnl.gov/help/Vsample/Rosners_Outlier_Test.htm\n// https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm\n// https://www.math.ucla.edu/~tom/distributions/KolSmir2.html?\nimport { DataFrame } from \"data-forge\";\nimport {\n  sampleStandardDeviation,\n  mean as _mean,\n  max,\n  median as _median,\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nimport { Studentt } from \"distributions\";\nimport dayjs from \"dayjs\";\n\nfunction rval(df) {\n  let values = df.deflate(row => row.x).toArray();\n  let std = sampleStandardDeviation(values);\n  let mean = _mean(values);\n  if (std === 0) {\n    let ndf = df.generateSeries({ ares: row => 0 });\n    return { R: 0, std, mean, df: ndf };\n  }\n  let ndf = new DataFrame({\n    values: values.map(x => ({\n      x,\n      ares: Math.abs(x - mean) / std\n    }))\n  });\n  let R = max(ndf.deflate(row => row.ares).toArray());\n  return { R, df: ndf, std, mean };\n}\n\nfunction pValue(n, i, alpha) {\n  let p = 1 - alpha / (2 * (n - i + 1));\n  return p;\n}\nfunction tValue(p, degreeOfFreedom) {\n  let qt = new Studentt(degreeOfFreedom);\n  let t = qt.inv(p);\n  return t;\n}\n//\nfunction lambdaTest(n, i, alpha) {\n  let p = pValue(n, i, alpha);\n  let df = n - i - 1;\n  let t = tValue(p, df);\n  let lambda =\n    (t * (n - i)) /\n    Math.sqrt((n - i - 1 + Math.pow(t, 2)) * (n - i + 1));\n  return { lambda, p, t };\n}\nfunction rosnerTest(dataset = [], k = 10, alpha = 0.05) {\n  let dataframe = new DataFrame({\n    values: dataset.map(x => ({ x }))\n  });\n  let n = dataframe.getSeries(\"x\").count();\n  let newdf;\n  let i = 1;\n  let outliers = [];\n  let trip = false;\n  while (i <= k) {\n    let pair = {};\n    let s = Date.now();\n    if (i === 1) {\n      let { R, df, mean, std } = rval(dataframe);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    } else {\n      let { R, df, mean, std } = rval(newdf);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    }\n    let { lambda, p, t } = lambdaTest(n, i, alpha);\n    pair = Object.assign({}, pair, { lambda });\n    outliers.push(pair);\n    if (trip && pair.R > pair.lambda) trip = false;\n    if (pair.R === 0) break;\n    if (pair.R < pair.lambda) {\n      if (trip) {\n        break;\n      } else {\n        trip = true;\n      }\n    }\n    i++;\n  }\n  outliers = new DataFrame(outliers)\n    .generateSeries({\n      outlier: row => row.R > row.lambda\n    })\n    .takeWhile(row => row.outlier);\n  let outlierValues = outliers\n    .where(row => row.Value > 0)\n    .deflate(row => row.Value);\n  let thresholds = {\n    lower: 0,\n    upper:\n      outlierValues.count() > 0 ? outlierValues.min() : Infinity\n  };\n  return {\n    outliers,\n    thresholds,\n    iterations: i\n  };\n}\nconst modz = (value, mad, median) => {\n  return (0.6745 * (value - median)) / mad;\n};\nfunction modifiedZScoreTest(values) {\n  let median = _median(values);\n  let mad = medianAbsoluteDeviation(values);\n  values = values\n    .sort((a, b) => b - a)\n    .filter(v => v > 0)\n    .map(v => [v, modz(v, mad, median)]);\n  let outliers = values.filter(\n    ([v, modz]) => Math.abs(modz) >= 3.5\n  );\n  let upper = Math.min(\n    ...[Infinity, ...outliers.map(v => v[0])]\n  );\n  // let score,\n  // \tvalue,\n  // \tthreshold = Infinity,\n  // \tindex = 0;\n  // do {\n  // \tvalue = values[index];\n  // \tscore = modz(value, mad, median);\n  // \tif (Math.abs(score) >= 3.5) threshold = value;\n  // } while (score >= 3.5);\n  return { thresholds: { upper, lower: 0 } };\n}\nfunction boxPlotTest(values) {\n  let q1 = quantile(values, 0.25);\n  let q3 = quantile(values, 0.75);\n  let iqr = q3 - q1;\n  return {\n    thresholds: {\n      lowerInner: q1 - 1.5 * iqr,\n      upperInner: q1 - 3 * iqr,\n      lowerOuter: q3 + 1.5 * iqr,\n      upperOuter: q3 + 3 * iqr\n    }\n  };\n}\nfunction calculateOutlierThresholds(\n  df,\n  { k, filterZeros = true } = {}\n) {\n  let values = df\n    .where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        Array.isArray(row.flag)\n    )\n    .where(row => !isNaN(row.value) && row.value !== null)\n    .getSeries(\"value\")\n    .bake();\n  if (filterZeros) values = values.where(value => value > 0);\n  if (!k) {\n    k =\n      values.count() < 1000\n        ? Math.floor(values.count() * 0.15)\n        : Math.min(...[1000, Math.floor(values.count() * 0.02)]);\n  }\n  if (values.count < 5) return {};\n  let { outliers, threshold } = rosnerTest(values.toArray(), k);\n  return { outliers, threshold };\n}\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  zeroGroups.forEach(dff => {\n    dff = dff.transformSeries({\n      value: value => null,\n      flag: value => [\"zero\"]\n    });\n    df = DataFrame.merge([df, dff]);\n  });\n  return df;\n}\nfunction isOutlier(value, { lower, upper }) {\n  if (value < lower || value >= upper) {\n    return true;\n  }\n  return false;\n}\nfunction validMean(df) {\n  let values = df\n    .getSeries(\"value\")\n    .where(value => typeof value === \"number\");\n  return values.average();\n}\nfunction validMonthlyMeanMap(df) {\n  let dateComparison = row =>\n    dayjs(row.date)\n      .startOf(\"month\")\n      .month();\n\n  df = df\n    .where(row => typeof row.value === \"number\")\n    .groupBy(dateComparison)\n    .select(group => ({\n      month: new Date(group.first().date).getMonth(),\n      value: group.deflate(row => row.value).average()\n    }));\n  return new Map(\n    df.toArray().map(({ month, value }) => [month, value])\n  );\n}\n\nfunction quality(df) {\n  let count = df.getIndex().count();\n  let valid = df\n    .getSeries(\"flag\")\n    .where(\n      value =>\n        value === null ||\n        (Array.isArray(value) && value.length === 0)\n    )\n    .count();\n  let missing = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"missing\") !== -1)\n    .count();\n  let dirty = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"clean\") !== -1)\n    .count();\n  let zerod = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"zero\") !== -1)\n    .count();\n  let breakdown = {\n    valid: valid / count,\n    missing: missing / count,\n    invalid: (dirty + zerod) / count\n  };\n  let report = {\n    accuracy: (1 - dirty / count) * 4,\n    completeness: 4 * breakdown.valid,\n    consistency: 4 * ((count - missing - zerod) / count)\n  };\n  return { breakdown, report, count };\n}\n\nexport {\n  rosnerTest,\n  modifiedZScoreTest,\n  boxPlotTest,\n  calculateOutlierThresholds,\n  zeroReplacement,\n  isOutlier,\n  validMean,\n  validMonthlyMeanMap,\n  quality\n};\n","import dayjs from \"dayjs\";\nimport dataForge from \"data-forge\";\nimport { msToInterval, intervalToMS } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport has from \"lodash/has\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\nimport {\n\trosnerTest,\n\tboxPlotTest,\n\tmodifiedZScoreTest\n} from \"./lib/Timeseries.statistics\";\nimport { annualScale, calculateChange } from \"./lib/misc\";\nimport { zeroCheck } from \"./lib/Timeseries.zero\";\nimport { timingSafeEqual } from \"crypto\";\n\nexport default Timeseries;\n\nfunction Timeseries(data) {\n\tif (data instanceof Timeseries) {\n\t\treturn data;\n\t}\n\tif (data instanceof dataForge.DataFrame) {\n\t\tdata = data.toArray();\n\t}\n\n\tdata = data\n\t\t.map(({ date, ...others }) => ({ date: dayjs(date), ...others }))\n\t\t.sort((a, b) => a.date.valueOf() - b.date.valueOf());\n\tlet config = {\n\t\t// columns: ['date', 'value', 'raw', 'flag'],\n\t\tvalues: data,\n\t\tindex: data.map(({ date }) => date.toDate()),\n\t\tconsiderAllRows: true\n\t};\n\tdataForge.DataFrame.call(this, config);\n}\n\nTimeseries.prototype = Object.create(dataForge.DataFrame.prototype);\nTimeseries.prototype.constructor = Timeseries;\n\n// Getters\nfunction getValueColumns() {\n\treturn this.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray();\n}\nfunction interval() {\n\tconst computeInterval = window => window.last() - window.first();\n\tconst intervals = this.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => -row.Frequency);\n\t// .orderBy(row => row.Value);\n\n\tlet val = intervals.first().Value;\n\n\treturn msToInterval(val);\n}\n\nfunction dateRange(unit, adjustment) {\n\tlet start = dayjs(this.first().date),\n\t\tend = dayjs(this.last().date);\n\tif (adjustment) {\n\t\tstart = start.startOf(adjustment);\n\t\tend = end.endOf(adjustment);\n\t}\n\treturn end.diff(start, unit);\n}\nTimeseries.prototype.getValueColumns = getValueColumns;\nTimeseries.prototype.getInterval = interval;\nTimeseries.prototype.getDateRange = dateRange;\n\n// Methods\nfunction calculateThresholdOptions({\n\tk,\n\tfilterZeros = true,\n\tfilterNegative = true\n} = {}) {\n\tlet noflags = this.where(\n\t\trow =>\n\t\t\trow.flag === null ||\n\t\t\trow.flag === undefined ||\n\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t)\n\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t.getSeries(\"value\");\n\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\tif (filterNegative) noflags = noflags.where(value => value > 0);\n\tif (!k) {\n\t\tk =\n\t\t\tnoflags.count() < 1000\n\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t}\n\tif (noflags.count() < 5) return {};\n\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\treturn { esd, box, modz };\n}\nfunction calculateStatistics(options = {}) {\n\tconst {\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = options;\n\tlet series = this.deflate(row => row[column]).where(value => !isNaN(value));\n\tif (filterNegative) series = series.where(value => value >= 0);\n\tif (filterZeros) series = series.where(value => value !== 0);\n\tlet median = series.median();\n\tlet mean = series.average();\n\tlet count = series.count();\n\tlet std = series.std();\n\tlet min = series.min();\n\tlet max = series.max();\n\tlet mad = medianAbsoluteDeviation(series.toArray());\n\tlet q1 = quantile(series.toArray(), 0.25);\n\tlet q3 = quantile(series.toArray(), 0.75);\n\tlet iqr = q3 - q1;\n\tlet stats = {\n\t\tmedian,\n\t\tmean,\n\t\tcount,\n\t\tstd,\n\t\tmin,\n\t\tmax,\n\t\tmad,\n\t\tq1,\n\t\tq3,\n\t\tiqr\n\t};\n\treturn stats;\n}\n\nTimeseries.prototype.calculateStatistics = calculateStatistics;\nTimeseries.prototype.calculateThresholdOptions = calculateThresholdOptions;\n\n// Chainable Methods\nfunction transformAllSeries(adjustmentFunction, { exclude }) {\n\tlet df = this;\n\tlet columns = (columns = df\n\t\t.detectTypes()\n\t\t.where(row => row.Type === \"number\")\n\t\t.distinct(row => row.Column)\n\t\t.getSeries(\"Column\")\n\t\t.toArray());\n\tif (exclude && Array.isArray(exclude)) {\n\t\tcolumns = columns.filter(col => exclude.indexOf(col) === -1);\n\t}\n\tcolumns.forEach(col => {\n\t\tdf = df.transformSeries({\n\t\t\t[col]: value => {\n\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\treturn df;\n}\n\nTimeseries.prototype.transformAllSeries = transformAllSeries;\n\nfunction reset() {\n\tlet df = this.withSeries({\n\t\tvalue: row =>\n\t\t\trow.flag && Array.isArray(row.flag) && row.flag.length > 0\n\t\t\t\t? row.raw\n\t\t\t\t: row.value\n\t})\n\t\t.subset([\"date\", \"value\"])\n\t\t.where(row => !isNaN(row.value) && row.value !== null);\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.reset = reset;\n\nfunction group(interval, toArray) {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\tlet groups = this.groupBy(dateComparison);\n\treturn groups;\n}\n\nTimeseries.prototype.group = group;\n\nfunction removeOutliers({\n\tcolumn = \"value\",\n\tlowerThreshold,\n\tupperThreshold\n} = {}) {\n\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\tvalue < lowerThreshold || value > upperThreshold;\n\n\tlet outliers = this.where(row =>\n\t\toutlierCheck(row[column], lowerThreshold, upperThreshold)\n\t)\n\t\t.generateSeries({\n\t\t\traw: row => row[column],\n\t\t\tflag: ({ flag = [] }) => [\"outlier\", ...flag]\n\t\t})\n\t\t.transformSeries({\n\t\t\t[column]: row => null\n\t\t});\n\t// let df = this.withSeries(\"raw\", outliers.getSeries(\"raw\")).withSeries(\n\t// \t\"flag\",\n\t// \toutliers.getSeries(\"flag\")\n\t// );\n\n\tlet merged = this.merge(outliers);\n\treturn new Timeseries(merged.toArray());\n}\n\nTimeseries.prototype.removeOutliers = removeOutliers;\nTimeseries.prototype.clean = removeOutliers;\n\nfunction downsample([duration, value], fillType = \"sum\") {\n\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\tthrow new Error(\"interval type not supported\");\n\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t}\n\tlet dateComparison = row => row.date.startOf(duration);\n\tlet valueColumns = this.getValueColumns();\n\tif (value) {\n\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t}\n\tlet df = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\t...fromPairs([\n\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t}),\n\t\t\t\t\t...group\n\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => dayjs(row.date).toDate());\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.downsample = downsample;\n\nfunction upsample([duration, value], fillType = \"avg\") {\n\t// Dont use this b/c it has the raw and flag values\n\tlet df = this.fillGaps(\n\t\tgapExists([duration, value]),\n\t\tgapFill(fillType, [duration, value])\n\t);\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.upsample = upsample;\n\nfunction populate(value, type = \"avg\") {\n\tlet v;\n\tswitch (type) {\n\t\tcase \"fill\":\n\t\t\tv = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = value / this.count();\n\t\t\tbreak;\n\t}\n\tlet df = this.generateSeries({ value: row => v });\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.populate = populate;\n\nfunction reduceToValue(columnNames) {\n\tfunction chooseValue(row, columnNames = []) {\n\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\treturn values[0] || 0;\n\t}\n\tlet df = this.generateSeries({\n\t\tvalue: row => chooseValue(row, columnNames)\n\t}).subset([\"date\", \"value\"]);\n\treturn new Timeseries(df);\n}\n\nTimeseries.prototype.reduceToValue = reduceToValue;\n\n// Baseline Functions\n\nfunction addBaselineDelta(baselineDF) {\n\t// Only Change in Year\n\tif (!(baselineDF instanceof Timeseries))\n\t\tbaselineDF = new Timeseries(baselineDF);\n\tlet dfwb;\n\tif (baselineDF.count() > 1) {\n\t\tlet interval = this.getInterval();\n\t\tlet baselineInterval = baselineDF.interval;\n\t\tif (!isEqual(interval, baselineInterval)) {\n\t\t\tconsole.error(interval, baselineInterval);\n\t\t\tthrow new Error(\"baseline and data intervals do not match\");\n\t\t}\n\t\tlet indexer;\n\t\tswitch (interval[0]) {\n\t\t\tcase \"day\":\n\t\t\t\tindexer = date => `${date.month()}-${date.date()}`;\n\t\t\t\tbreak;\n\t\t\tcase \"month\":\n\t\t\t\tindexer = date => date.month();\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tindexer = date => 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet indexedBaseline = baselineDF.withIndex(row => indexer(row.date));\n\t\tlet getBaselineValue = index => {\n\t\t\tlet at = indexedBaseline.at(index);\n\t\t\tif (at && has(at, \"value\")) {\n\t\t\t\treturn at.value;\n\t\t\t} else {\n\t\t\t\treturn indexedBaseline.getSeries(\"value\").average();\n\t\t\t}\n\t\t};\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => getBaselineValue(indexer(row.date))\n\t\t});\n\t} else {\n\t\tdfwb = this.generateSeries({\n\t\t\tbaseline: row => baselineDF.first().value\n\t\t});\n\t}\n\tdfwb = dfwb.generateSeries({\n\t\tdelta: row => calculateChange(row.baseline, row.value)\n\t});\n\treturn new Timeseries(dfwb);\n}\n\nTimeseries.prototype.addBaselineDelta = addBaselineDelta;\n\nfunction annualIntensity(normalizeValue = 1) {\n\tlet interval = this.getInterval();\n\tlet annual = this.groupBy(row => row.date.year())\n\t\t.select(group => {\n\t\t\tlet startDate = group.first().date;\n\t\t\tlet endDate = group\n\t\t\t\t.last()\n\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\treturn {\n\t\t\t\tstartDate,\n\t\t\t\tendDate,\n\t\t\t\t...fromPairs(\n\t\t\t\t\tthis.getValueColumns().map(col => [\n\t\t\t\t\t\tcol,\n\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.renameSeries({ startDate: \"date\" })\n\t\t.dropSeries(\"endDate\");\n\treturn new Timeseries(annual);\n}\n\nTimeseries.prototype.annualIntensity = annualIntensity;\n\n// Fill Functions\n\nfunction fillMissing() {\n\tlet startDate = this.first().date.toDate(),\n\t\tendDate = this.last().date.toDate();\n\tlet interval = this.getInterval();\n\tlet bdf = Timeseries.blank(startDate, endDate, interval, \"missing\").withIndex(\n\t\trow => row.date.valueOf()\n\t);\n\tlet m = this.withIndex(row => row.date.valueOf()).merge(bdf);\n\tm = m.transformSeries({\n\t\tflag: row => (row.value ? undefined : row.flag)\n\t});\n\tm = new Timeseries(m);\n\treturn m;\n}\nTimeseries.prototype.fillMissing = fillMissing;\nfunction fillNull(v) {\n\tlet df = this.transformSeries({\n\t\tvalue: value => (value === null || value === undefined ? v : value)\n\t});\n\treturn new Timeseries(df);\n}\nTimeseries.prototype.fillNull = fillNull;\n\nfunction zeroReplacement(threshold) {\n\tlet df = this;\n\tlet { zeroGroups } = zeroCheck(df, threshold);\n\tlet dfs = zeroGroups.toArray().map((zdf, i) => {\n\t\tzdf = zdf\n\t\t\t.transformSeries({\n\t\t\t\tvalue: () => null,\n\t\t\t\traw: () => 0,\n\t\t\t\tflag: value => [\"zero\", ...(value || [])]\n\t\t\t})\n\t\t\t.withIndex(row => new Date(row.date).valueOf());\n\t\treturn zdf;\n\t});\n\tlet merged = df.withIndex(row => row.date.valueOf()).merge(...dfs);\n\treturn new Timeseries(merged);\n}\nTimeseries.prototype.zeroReplacement = zeroReplacement;\n\nfunction monthlyWithQual() {\n\tlet interval = this.getInterval();\n\tlet ms = intervalToMS(interval);\n\tconst duration = \"month\";\n\tlet dateComparison = row =>\n\t\tdayjs(row.date)\n\t\t\t.startOf()\n\t\t\t.valueOf();\n\tlet ts = this.groupBy(dateComparison)\n\t\t.select(group => {\n\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t.startOf(duration)\n\t\t\t\t.toDate();\n\t\t\tlet fullCount = Math.floor(\n\t\t\t\tdayjs(date)\n\t\t\t\t\t.endOf(\"month\")\n\t\t\t\t\t.diff(dayjs(date), \"millisecond\") / ms\n\t\t\t);\n\t\t\tlet days = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n\t\t\tlet count = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => v && v !== 0)\n\t\t\t\t.toArray().length;\n\t\t\tlet value = group\n\t\t\t\t.getSeries(\"value\")\n\t\t\t\t.where(v => !isNaN(v))\n\t\t\t\t.sum();\n\t\t\treturn {\n\t\t\t\tdate,\n\t\t\t\tvalue: isNaN(value) ? 0 : value,\n\t\t\t\tcount,\n\t\t\t\tfullCount,\n\t\t\t\tscore: count / fullCount\n\t\t\t};\n\t\t})\n\t\t.inflate()\n\t\t.withIndex(row => row.date.toDate());\n\treturn new Timeseries(ts);\n}\nTimeseries.prototype.monthlyWithQual = monthlyWithQual;\n\nfunction threeYearAverage(date, column = \"value\", defaultValue) {\n\tdate = dayjs(date);\n\tif (!defaultValue)\n\t\tdefaultValue = this.getSeries(\"value\")\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\n\t// let months = df\n\t// \t.before(date.valueOf())\n\t// \t.where(row => dayjs(row.date).month() === date.month())\n\t// \t.where(row => row.score > 0.9)\n\t// \t.tail(3);\n\tlet months = this.before(date.toDate())\n\t\t.where(row => row.date.month() === date.month())\n\t\t.orderBy(row => dayjs(row.date))\n\t\t.tail(3);\n\t// .where(row => row.score > 0.9);\n\tif (months.count() > 0) {\n\t\tlet val = months\n\t\t\t.getSeries(column)\n\t\t\t.where(v => !isNaN(v) && v !== null)\n\t\t\t.average();\n\t\treturn val;\n\t} else {\n\t\treturn defaultValue;\n\t}\n}\nTimeseries.prototype.threeYearAverage = threeYearAverage;\n\nfunction averageFill() {\n\tlet df = this;\n\tlet avg = df\n\t\t// .where(row => row.score ?row.score >= 0.9)\n\t\t.getSeries(\"value\")\n\t\t.where(v => !isNaN(v) && v !== null)\n\t\t.average();\n\tlet monthlyAvg = df\n\t\t.generateSeries({\n\t\t\trollingAverage: row => df.threeYearAverage(row.date, \"value\", avg)\n\t\t})\n\t\t.generateSeries({\n\t\t\tflag: row => (row.value ? row.flag : [\"filled\", ...(row.flag || [])])\n\t\t})\n\t\t.generateSeries({\n\t\t\tvalue: row => (row.value ? row.value : row.rollingAverage)\n\t\t})\n\t\t.dropSeries([\"rollingAverage\"]);\n\treturn new Timeseries(monthlyAvg);\n}\n\nTimeseries.prototype.averageFill = averageFill;\n\n// Static Methods\nfunction blank(startDate, endDate, [duration, value = 1], flag) {\n\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\tconsole.error(interval);\n\t\tthrow new Error(\"interval type not supported\");\n\t}\n\tstartDate = dayjs(startDate);\n\tendDate = dayjs(endDate);\n\tlet dates = [startDate];\n\tlet interval = intervalToMS([duration, value]);\n\twhile (dates[dates.length - 1].valueOf() < endDate.valueOf()) {\n\t\tdates.push(dayjs(dates[dates.length - 1]).add(value, duration));\n\t}\n\tlet df = new Timeseries(dates.map(date => ({ date, ...(flag && { flag }) })));\n\t// if (flag) {\n\t// \tdf = df.generateSeries({\n\t// \t\tflag: row => [flag]\n\t// \t});\n\t// \tdf = new Timeseries(df);\n\t// }\n\treturn df;\n}\nTimeseries.blank = blank;\nfunction aggregate(dataframes) {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df));\n\tconst valueColumns = new Set(\n\t\tdataframes.map(df => df.getValueColumns()).reduce((a, b) => a.concat(b), [])\n\t);\n\tconst concatenated = dataForge.DataFrame.concat(dataframes)\n\t\t.groupBy(row => row.date)\n\t\t.select(group => {\n\t\t\tconst date = group.first().date;\n\t\t\tlet o = { date };\n\t\t\tvalueColumns.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\tgroup\n\t\t\t\t.getColumnNames()\n\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t.filter(col => valueColumns.has(col) === -1)\n\t\t\t\t.forEach(col => {\n\t\t\t\t\tlet value = group\n\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t.toArray();\n\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\to[col] = value;\n\t\t\t\t\treturn;\n\t\t\t\t});\n\t\t\treturn o;\n\t\t})\n\t\t.inflate();\n\t// .toArray();\n\n\treturn new Timeseries(concatenated);\n}\nTimeseries.aggregate = aggregate;\nTimeseries.concat = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df));\n\tlet df = dataForge.DataFrame.concat(dataframes);\n\treturn new Timeseries(df);\n};\nTimeseries.merge = dataframes => {\n\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\tdataframes = dataframes.map(df => new Timeseries(df));\n\tlet df = dataForge.DataFrame.merge(dataframes);\n\treturn new Timeseries(df);\n};\n","import dayjs from \"dayjs\";\nexport const annualScale = (start, end) =>\n\t365 / dayjs(end).diff(dayjs(start), \"day\");\nexport const calculateChange = (baseline, value) =>\n\t(value - baseline) / baseline;\n","import { DataFrame } from \"data-forge\";\n\nconst zerogrouping = dataframe => {\n  // group sequential\n  let df = dataframe.variableWindow(\n    (a, b) => a.value === b.value\n  );\n};\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  let dfs = zeroGroups.toArray().map(zdf => {\n    zdf = zdf\n      .transformSeries({\n        value: () => null,\n        raw: 0,\n        flag: value => [\"zero\", ...(value || [])]\n      })\n      .withIndex(row => new Date(row.date).valueOf());\n    return zdf;\n  });\n  let merged = DataFrame.merge([df, ...dfs]);\n\n  return merged;\n}\nexport { zerogrouping, zeroReplacement, zeroCheck };\n"],"names":["intervalToMS","unit","value","start","dayjs","add","diff","valueFiller","fillType","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","rval","df","values","deflate","row","x","toArray","std","sampleStandardDeviation","mean","_mean","ndf","generateSeries","ares","R","DataFrame","Math","abs","max","lambdaTest","n","i","alpha","p","pValue","t","degreeOfFreedom","Studentt","inv","tValue","lambda","sqrt","pow","modz","mad","median","modifiedZScoreTest","_median","medianAbsoluteDeviation","outliers","sort","a","b","filter","v","thresholds","upper","min","Infinity","lower","Timeseries","data","dataForge","config","others","valueOf","index","toDate","considerAllRows","call","this","removeOutliers","column","lowerThreshold","upperThreshold","where","outlierCheck","raw","transformSeries","merge","prototype","Object","create","constructor","getValueColumns","detectTypes","Type","distinct","Column","getSeries","getInterval","ms","end","getIndex","window","select","last","first","detectValues","orderBy","Frequency","Value","ceil","getDateRange","adjustment","startOf","endOf","calculateStatistics","options","filterZeros","filterNegative","series","isNaN","average","count","q1","quantile","q3","iqr","calculateThresholdOptions","k","noflags","Array","isArray","length","floor","esd","dataset","newdf","dataframe","trip","pair","assign","push","outlierValues","outlier","takeWhile","iterations","rosnerTest","box","lowerInner","upperInner","lowerOuter","upperOuter","transformAllSeries","adjustmentFunction","exclude","columns","col","forEach","reset","withSeries","subset","group","interval","groupBy","clean","downsample","duration","dateComparison","valueColumns","sum","getColumnNames","inflate","withIndex","upsample","fillGaps","durationValue","pairA","pairB","startDate","gapExists","endDate","newEntries","e","gapFill","populate","type","reduceToValue","columnNames","chooseValue","addBaselineDelta","baselineDF","dfwb","indexer","baselineInterval","isEqual","console","error","month","indexedBaseline","baseline","at","has","delta","annualIntensity","normalizeValue","year","scaler","_this","renameSeries","dropSeries","fillMissing","bdf","blank","m","undefined","fillNull","zeroReplacement","threshold","dfs","zeroGroups","variableWindow","zeroSummary","zeroCheck","zdf","Date","monthlyWithQual","fullCount","getFullYear","getMonth","getDate","score","threeYearAverage","defaultValue","months","before","tail","averageFill","avg","rollingAverage","dates","aggregate","dataframes","Set","reduce","concat","o","c"],"mappings":"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"}
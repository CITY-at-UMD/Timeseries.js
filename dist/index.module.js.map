{"version":3,"file":"index.module.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n  let start = dayjs();\n  let end = dayjs().add(ms);\n  if (end.diff(start, \"year\", true) >= 1) {\n    return [\"year\", end.diff(start, \"year\")];\n  } else if (end.diff(start, \"month\", true) >= 1) {\n    return [\"month\", end.diff(start, \"month\")];\n  } else if (end.diff(start, \"day\", true) >= 1) {\n    return [\"day\", end.diff(start, \"day\")];\n  } else if (end.diff(start, \"hour\", true) >= 1) {\n    return [\"hour\", end.diff(start, \"hour\")];\n  } else {\n    return [\"minute\", end.diff(start, \"minute\")];\n  }\n};\n\nfunction calculateInterval(df, startDate, endDate) {\n  if (!startDate) startDate = df.first.date;\n  if (!endDate) endDate = df.last.date;\n  function computeInterval(window) {\n    return window.last() - window.first();\n  }\n  const intervals = df\n    .between(startDate, endDate)\n    .getIndex()\n    .window(2)\n    .select(computeInterval)\n    .detectValues()\n    .orderBy(row => row.Frequency);\n\n  let val = intervals.last().Value;\n  return msToInterval(val);\n}\nexport { msToInterval, calculateInterval };\n","import dayjs from \"dayjs\";\nimport _ from \"lodash\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration, true) /\n      durationValue\n  );\n\n  if (gapSize > 0) return true;\n  return false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize;\n  if (interval === \"quarterHour\") {\n    gapSize = Math.floor(\n      dayjs(endDate).diff(startDate, \"minutes\") / 15\n    );\n  } else {\n    gapSize = dayjs(endDate).diff(startDate, interval);\n  }\n  if (maxGap && maxGap > gapSize) return false;\n  if (gapSize > 0) return true;\n  return false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const newEntries = [];\n\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let date = dayjs(startDate)\n      .add((entryIndex + 1) * durationValue, duration)\n      .toDate();\n    newEntries.push([\n      date.valueOf(),\n      { date, value: null, ...(flag && { flag: [flag] }) }\n    ]);\n  }\n  return newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n  fillType,\n  { startValue, endValue, entryIndex, numEntries },\n  { overrideValue, dateFunction, date, flag }\n) => {\n  if (\n    [\n      \"pad\",\n      \"interpolate\",\n      \"average\",\n      \"dateFunction\",\n      \"value\"\n    ].indexOf(fillType) === -1\n  ) {\n    throw new Error(\"fill Type not supported\");\n  }\n  let value;\n  if (fillType === \"pad\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, startValue[key]];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", \"pad\"];\n  } else if (fillType === \"interpolate\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv =\n          startValue[key] +\n          (entryIndex + 1) *\n            ((endValue[key] - startValue[key]) /\n              (numEntries + 1));\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"average\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = (startValue[key] + endValue[key]) / numEntries;\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"dateFunction\" && dateFunction) {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = dateFunction(date);\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"value\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv;\n        if (typeof overrideValue === \"number\") {\n          nv = overrideValue;\n        } else {\n          nv = overrideValue[key];\n        }\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, null];\n      })\n    );\n    flag = [\"fill\"];\n  }\n  return { ...value, flag };\n};\n\nconst gapFill = (\n  fillType,\n  [duration, durationValue],\n  { overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n  // Fill values forward.\n\n  const startDate = dayjs(pairA[0]);\n  const endDate = dayjs(pairB[0]);\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const startValue = pairA[1];\n  const endValue = pairB[1];\n  const newEntries = [];\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let adjustment = valueFiller(\n        fillType,\n        { startValue, endValue, entryIndex, numEntries },\n        {\n          overrideValue,\n          dateFunction,\n          flag\n        }\n      ),\n      date = dayjs(startDate)\n        .add((entryIndex + 1) * durationValue, duration)\n        .toDate();\n    let e = [\n      date.valueOf(),\n      Object.assign({}, adjustment, { date })\n    ];\n    newEntries.push(e);\n  }\n\n  return newEntries;\n};\n\nexport {\n  gapExists,\n  gapFill,\n  gapFillBlank,\n  gapFillNull,\n  valueFiller\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\n\nclass Timeseries extends DataFrame {\n\tconstructor(data = []) {\n\t\tif (data instanceof Timeseries) return data;\n\t\tif (data instanceof DataFrame) {\n\t\t\tdata = data.toArray();\n\t\t}\n\t\t// sort\n\t\tdata = data.sort(\n\t\t\t(a, b) => new Date(a.date).valueOf() - new Date(b.date).valueOf()\n\t\t);\n\t\tlet config = {\n\t\t\tvalues: data,\n\t\t\tindex: data.map(({ date }) => new Date(date).valueOf()),\n\t\t\t// columns: [\n\t\t\t// \t...new Set(data.map(o => Object.keys(o)).reduce((a, b) => a.concat(b)))\n\t\t\t// ]\n\t\t\tconsiderAllRows: true\n\t\t};\n\t\tsuper(config);\n\t}\n\tget interval() {\n\t\tlet startDate = this.first().date;\n\t\tlet endDate = this.last().date;\n\t\tfunction computeInterval(window) {\n\t\t\treturn window.last() - window.first();\n\t\t}\n\t\tconst intervals = this.between(startDate, endDate)\n\t\t\t.getIndex()\n\t\t\t.window(2)\n\t\t\t.select(computeInterval)\n\t\t\t.detectValues()\n\t\t\t.orderBy(row => row.Frequency)\n\t\t\t.orderBy(row => row.Value);\n\t\tlet val = intervals.last().Value;\n\t\treturn msToInterval(val);\n\t}\n\tdateRange(unit, adjustment) {\n\t\tlet start = dayjs(this.first().date),\n\t\t\tend = dayjs(this.last().date);\n\t\tif (adjustment) {\n\t\t\tstart = start.startOf(adjustment);\n\t\t\tend = end.endOf(adjustment);\n\t\t}\n\t\treturn end.diff(start, unit);\n\t}\n\tat(date) {\n\t\treturn super.at(new Date(date).valueOf());\n\t}\n\tcalculateThresholds({ k, filterZeros = true } = {}) {\n\t\tlet noflags = this.where(\n\t\t\trow =>\n\t\t\t\trow.flag === null ||\n\t\t\t\trow.flag === undefined ||\n\t\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t\t)\n\t\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t\t.getSeries(\"value\");\n\t\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\t\tif (!k) {\n\t\t\tk =\n\t\t\t\tnoflags.count() < 1000\n\t\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t\t}\n\t\tif (noflags.count() < 5) return {};\n\t\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\t\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\t\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\t\treturn { esd, box, modz };\n\t}\n\tcalculateStatistics({\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = {}) {\n\t\tlet series = this.deflate(row => row[columnName]).where(\n\t\t\tvalue => !isNaN(value)\n\t\t);\n\t\tif (filterNegative) series = series.where(value => value >= 0);\n\t\tif (filterZeros) series = series.where(value => value !== 0);\n\t\tlet median = series.median();\n\t\tlet mean = series.average();\n\t\tlet count = series.count();\n\t\tlet std = series.std();\n\t\tlet min = series.min();\n\t\tlet max = series.max();\n\t\tlet mad = medianAbsoluteDeviation(series.toArray());\n\t\tlet q1 = quantile(series.toArray(), 0.25);\n\t\tlet q3 = quantile(series.toArray(), 0.75);\n\t\tlet iqr = q3 - q1;\n\t\tlet stats = {\n\t\t\tmedian,\n\t\t\tmean,\n\t\t\tcount,\n\t\t\tstd,\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tmad,\n\t\t\tq1,\n\t\t\tq3,\n\t\t\tiqr\n\t\t};\n\t\treturn stats;\n\t}\n\tdataQuality() {\n\t\tlet count = this.count();\n\t\tlet valid = this.getSeries(\"flag\")\n\t\t\t.where(\n\t\t\t\tvalue =>\n\t\t\t\t\tvalue === null ||\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t)\n\t\t\t.count();\n\t\tlet missing = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"missing\") !== -1)\n\t\t\t.count();\n\t\tlet invalid = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"outlier\") !== -1)\n\t\t\t.count();\n\t\tlet zeroFill = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"zeroFill\") !== -1)\n\t\t\t.count();\n\t\tlet breakdown = {\n\t\t\tvalid: valid / count,\n\t\t\tmissing: missing / count,\n\t\t\tinvalid: invalid / count\n\t\t};\n\t\tlet report = {\n\t\t\taccuracy: 0,\n\t\t\tcompleteness: 0,\n\t\t\tconsistency: 0\n\t\t};\n\t\treturn {};\n\t}\n\t// Chainable Methods\n\ttransformAll(adjustmentFunction = v => v, columns) {\n\t\tlet df = this;\n\t\tif (!columns) {\n\t\t\tcolumns = df\n\t\t\t\t.detectTypes()\n\t\t\t\t.where(row => row.Type === \"number\")\n\t\t\t\t.distinct(row => row.Column)\n\t\t\t\t.getSeries(\"Column\")\n\t\t\t\t.toArray();\n\t\t}\n\t\tcolumns.forEach(col => {\n\t\t\tdf = df.transformSeries({\n\t\t\t\t[col]: value => {\n\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\tremoveOutliers({ lowerThreshold, upperThreshold } = {}) {\n\t\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\t\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\t\tvalue < lowerThreshold || value > upperThreshold;\n\t\tlet df = this.generateSeries({\n\t\t\traw: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? row.value\n\t\t\t\t\t: null,\n\t\t\tflag: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? [\"outlier\"]\n\t\t\t\t\t: null\n\t\t}).transformSeries({\n\t\t\tvalue: value =>\n\t\t\t\toutlierCheck(value, lowerThreshold, upperThreshold) ? null : value\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\treset() {\n\t\treturn this.withSeries({\n\t\t\tvalue: row => (row.raw && !isNaN(row.raw) ? row.raw : row.value)\n\t\t}).dropSeries([\"flag\", \"raw\"]);\n\t}\n\tgroup(interval, toArray) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\t\tlet groups = this.groupBy(dateComparison);\n\t\treturn groups;\n\t}\n\t// Not Working Yet, downsample and upsample independently work\n\tresample([duration, value = 1], fillType) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet interval = this.interval;\n\t\tif (isEqual(interval, [duration, value])) {\n\t\t\treturn this;\n\t\t}\n\t\tlet d0 = dayjs(0);\n\t\tlet currentSampleDiff = dayjs(0)\n\t\t\t.add(interval[1], interval[0])\n\t\t\t.diff(d0);\n\t\tlet newSampleDiff = dayjs(0)\n\t\t\t.add(value, duration)\n\t\t\t.diff(d0);\n\t\tif (currentSampleDiff < newSampleDiff) {\n\t\t\treturn this.downsample([duration, value], fillType);\n\t\t} else {\n\t\t\treturn this.upsample([duration, value], fillType);\n\t\t}\n\t}\n\tupsample([duration, value], fillType = \"avg\") {\n\t\t// Dont use this b/c it has the raw and flag values\n\t\tlet df = this.fillGaps(\n\t\t\tgapExists([duration, value]),\n\t\t\tgapFill(fillType, [duration, value])\n\t\t);\n\t\treturn new Timeseries(df);\n\t}\n\tdownsample([duration, value], fillType = \"sum\") {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t\t}\n\t\tlet dateComparison = row => dayjs(row.date).startOf(duration);\n\t\tif (value)\n\t\t\tdateComparison = row =>\n\t\t\t\tdayjs(row.date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.add(value, duration);\n\t\tlet df = this.groupBy(dateComparison)\n\t\t\t.select(group => {\n\t\t\t\tconst date = dayjs(group.first().date)\n\t\t\t\t\t.startOf(duration)\n\t\t\t\t\t.toDate();\n\t\t\t\treturn {\n\t\t\t\t\tdate,\n\t\t\t\t\t...fromPairs(\n\t\t\t\t\t\tgroup\n\t\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).median();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).average();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\t\t\tvalue = group.deflate(row => row[col]).sum();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.withIndex(row => row.date.valueOf());\n\t\treturn new Timeseries(df);\n\t}\n\n\tpopulate(value, type = \"avg\") {\n\t\tlet v;\n\t\tswitch (type) {\n\t\t\tcase \"fill\":\n\t\t\t\tv = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = value / this.getIndex().count();\n\t\t\t\tbreak;\n\t\t}\n\t\tlet df = this.generateSeries({ value: row => v });\n\t\treturn new Timeseries(df);\n\t}\n\tfill(interval, fillType) {\n\t\t// let interval = this.interval;\n\t\tif (!interval || !Array.isArray(interval)) interval = this.interval;\n\t\tlet ndf = this.fillGaps(gapExists(interval), gapFill(fillType, interval));\n\t\treturn new Timeseries(ndf);\n\t}\n\treduceToValue(columnNames) {\n\t\tfunction chooseValue(row, columnNames = []) {\n\t\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\t\treturn values[0] || 0;\n\t\t}\n\t\tlet df = this.generateSeries({\n\t\t\tvalue: row => chooseValue(row, columnNames)\n\t\t}).subset([\"date\", \"value\"]);\n\t\treturn new Timeseries(df);\n\t}\n\tclean(columnName = \"value\", { lowerThreshold, upperThreshold }) {\n\t\tlet arr = this.toArray().map(row => {\n\t\t\tlet value = row[columnName];\n\t\t\tif (value > upperThreshold || value < lowerThreshold) {\n\t\t\t\treturn { ...row, value: undefined, raw: value };\n\t\t\t} else {\n\t\t\t\treturn row;\n\t\t\t}\n\t\t});\n\t\treturn new Timeseries(arr);\n\t}\n\t// Static Methods\n\tstatic blank(startDate, endDate, [duration, value = 1]) {\n\t\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\t\tconsole.error(interval);\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\t}\n\t\tlet df = new Timeseries([\n\t\t\t{ date: new Date(startDate) },\n\t\t\t{ date: new Date(endDate) }\n\t\t])\n\t\t\t.fillGaps(gapExists([duration, value]), gapFillBlank([duration, value]))\n\t\t\t.between(startDate, endDate);\n\t\treturn new Timeseries(df);\n\t}\n\tstatic aggregate(dataframes) {\n\t\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\t\tdataframes = dataframes.map(df => new Timeseries(df));\n\t\tconst concatenated = DataFrame.concat(dataframes)\n\t\t\t.groupBy(row => row.date)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date;\n\t\t\t\tlet o = { date };\n\t\t\t\tgroup\n\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t.filter(c => c !== \"date\")\n\t\t\t\t\t.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\t\treturn o;\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.toArray();\n\t\treturn new Timeseries(concatenated);\n\t}\n\t// Models\n\tannualMonthlyAverage({ startDate, endDate }) {\n\t\tlet months = this.downsample([\"month\", 1], \"sum\").between(\n\t\t\tstartDate,\n\t\t\tendDate\n\t\t);\n\t\tlet avg = months.getSeries(\"value\").average();\n\t}\n}\nexport default Timeseries;\n"],"names":["gapExists","duration","durationValue","pairA","pairB","startDate","Math","floor","dayjs","diff","valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","gapFill","endDate","newEntries","adjustment","add","toDate","e","valueOf","Object","assign","push","Timeseries","data","DataFrame","toArray","config","values","sort","a","b","Date","index","considerAllRows","dateRange","unit","start","this","first","end","last","startOf","endOf","at","calculateThresholds","k","filterZeros","noflags","where","row","Array","isArray","length","isNaN","getSeries","count","min","esd","rosnerTest","thresholds","box","boxPlotTest","modz","modifiedZScoreTest","calculateStatistics","filterNegative","series","deflate","columnName","median","mean","average","std","max","mad","medianAbsoluteDeviation","q1","quantile","q3","iqr","dataQuality","transformAll","adjustmentFunction","columns","v","df","detectTypes","Type","distinct","Column","forEach","col","transformSeries","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","generateSeries","raw","reset","withSeries","dropSeries","group","interval","groupBy","resample","isEqual","d0","downsample","upsample","fillGaps","dateComparison","select","getColumnNames","filter","sum","inflate","withIndex","populate","type","getIndex","fill","reduceToValue","columnNames","n","chooseValue","subset","clean","undefined","blank","console","error","gapFillBlank","between","aggregate","dataframes","concat","o","c","annualMonthlyAverage","ms","window","detectValues","orderBy","Frequency","Value"],"mappings":"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"}
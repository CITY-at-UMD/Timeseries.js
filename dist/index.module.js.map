{"version":3,"file":"index.module.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tconsole.log(end.diff(start, \"day\"));\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\n\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration, true) /\n      durationValue\n  );\n\n  if (gapSize > 0) return true;\n  return false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize;\n  if (interval === \"quarterHour\") {\n    gapSize = Math.floor(\n      dayjs(endDate).diff(startDate, \"minutes\") / 15\n    );\n  } else {\n    gapSize = dayjs(endDate).diff(startDate, interval);\n  }\n  if (maxGap && maxGap > gapSize) return false;\n  if (gapSize > 0) return true;\n  return false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (\n  pairA,\n  pairB\n) => {\n  const startDate = pairA[0];\n  const endDate = pairB[0];\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const newEntries = [];\n\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let date = dayjs(startDate)\n      .add((entryIndex + 1) * durationValue, duration)\n      .toDate();\n    newEntries.push([\n      date.valueOf(),\n      { date, value: null, ...(flag && { flag: [flag] }) }\n    ]);\n  }\n  return newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n  fillType,\n  { startValue, endValue, entryIndex, numEntries },\n  { overrideValue, dateFunction, date, flag }\n) => {\n  if (\n    [\n      \"pad\",\n      \"interpolate\",\n      \"average\",\n      \"dateFunction\",\n      \"value\"\n    ].indexOf(fillType) === -1\n  ) {\n    throw new Error(\"fill Type not supported\");\n  }\n  let value;\n  if (fillType === \"pad\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, startValue[key]];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", \"pad\"];\n  } else if (fillType === \"interpolate\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv =\n          startValue[key] +\n          (entryIndex + 1) *\n            ((endValue[key] - startValue[key]) /\n              (numEntries + 1));\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"average\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = (startValue[key] + endValue[key]) / numEntries;\n        return [key, nv];\n      })\n    );\n\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"dateFunction\" && dateFunction) {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv = dateFunction(date);\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else if (fillType === \"value\") {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        let nv;\n        if (typeof overrideValue === \"number\") {\n          nv = overrideValue;\n        } else {\n          nv = overrideValue[key];\n        }\n        return [key, nv];\n      })\n    );\n    flag = flag ? flag : [\"fill\", fillType];\n  } else {\n    value = fromPairs(\n      toPairs(startValue).map(([key, val]) => {\n        return [key, null];\n      })\n    );\n    flag = [\"fill\"];\n  }\n  return { ...value, flag };\n};\n\nconst gapFill = (\n  fillType,\n  [duration, durationValue],\n  { overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n  // Fill values forward.\n\n  const startDate = dayjs(pairA[0]);\n  const endDate = dayjs(pairB[0]);\n  let gapSize = Math.floor(\n    dayjs(endDate).diff(startDate, duration) / durationValue\n  );\n  const numEntries = gapSize - 1;\n  const startValue = pairA[1];\n  const endValue = pairB[1];\n  const newEntries = [];\n  for (\n    let entryIndex = 0;\n    entryIndex < numEntries;\n    ++entryIndex\n  ) {\n    let adjustment = valueFiller(\n        fillType,\n        { startValue, endValue, entryIndex, numEntries },\n        {\n          overrideValue,\n          dateFunction,\n          flag\n        }\n      ),\n      date = dayjs(startDate)\n        .add((entryIndex + 1) * durationValue, duration)\n        .toDate();\n    let e = [\n      date.valueOf(),\n      Object.assign({}, adjustment, { date })\n    ];\n    newEntries.push(e);\n  }\n\n  return newEntries;\n};\n\nexport {\n  gapExists,\n  gapFill,\n  gapFillBlank,\n  gapFillNull,\n  valueFiller\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\n\nconst annualScale = (start, end) => 365 / dayjs(end).diff(dayjs(start), \"day\");\n\nclass Timeseries extends DataFrame {\n\tconstructor(data = []) {\n\t\tif (data instanceof Timeseries) return data;\n\t\tif (data instanceof DataFrame) {\n\t\t\tdata = data.toArray();\n\t\t}\n\t\t// sort\n\t\tdata = data\n\t\t\t.map(({ date, ...others }) => ({ date: dayjs(date), ...others }))\n\t\t\t.sort((a, b) => a.date.valueOf() - b.date.valueOf());\n\t\tlet config = {\n\t\t\tvalues: data,\n\t\t\tindex: data.map(({ date }) => date.toDate()),\n\t\t\tconsiderAllRows: true\n\t\t};\n\t\tsuper(config);\n\t}\n\tget interval() {\n\t\tfunction computeInterval(window) {\n\t\t\treturn window.last() - window.first();\n\t\t}\n\t\tconst intervals = this.getIndex()\n\t\t\t.window(2)\n\t\t\t.select(computeInterval)\n\t\t\t.detectValues()\n\t\t\t.orderBy(row => row.Frequency)\n\t\t\t.orderBy(row => row.Value);\n\t\tlet val = intervals.last().Value;\n\t\treturn msToInterval(val);\n\t}\n\tget valueColumns() {\n\t\treturn this.detectTypes()\n\t\t\t.where(row => row.Type === \"number\")\n\t\t\t.distinct(row => row.Column)\n\t\t\t.getSeries(\"Column\")\n\t\t\t.toArray();\n\t}\n\tdateRange(unit, adjustment) {\n\t\tlet start = dayjs(this.first().date),\n\t\t\tend = dayjs(this.last().date);\n\t\tif (adjustment) {\n\t\t\tstart = start.startOf(adjustment);\n\t\t\tend = end.endOf(adjustment);\n\t\t}\n\t\treturn end.diff(start, unit);\n\t}\n\tat(date) {\n\t\treturn super.at(dayjs(date));\n\t}\n\tcalculateThresholds({ k, filterZeros = true } = {}) {\n\t\tlet noflags = this.where(\n\t\t\trow =>\n\t\t\t\trow.flag === null ||\n\t\t\t\trow.flag === undefined ||\n\t\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t\t)\n\t\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t\t.getSeries(\"value\");\n\t\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\t\tif (!k) {\n\t\t\tk =\n\t\t\t\tnoflags.count() < 1000\n\t\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t\t}\n\t\tif (noflags.count() < 5) return {};\n\t\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\t\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\t\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\t\treturn { esd, box, modz };\n\t}\n\tcalculateStatistics({\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = {}) {\n\t\tlet series = this.deflate(row => row[columnName]).where(\n\t\t\tvalue => !isNaN(value)\n\t\t);\n\t\tif (filterNegative) series = series.where(value => value >= 0);\n\t\tif (filterZeros) series = series.where(value => value !== 0);\n\t\tlet median = series.median();\n\t\tlet mean = series.average();\n\t\tlet count = series.count();\n\t\tlet std = series.std();\n\t\tlet min = series.min();\n\t\tlet max = series.max();\n\t\tlet mad = medianAbsoluteDeviation(series.toArray());\n\t\tlet q1 = quantile(series.toArray(), 0.25);\n\t\tlet q3 = quantile(series.toArray(), 0.75);\n\t\tlet iqr = q3 - q1;\n\t\tlet stats = {\n\t\t\tmedian,\n\t\t\tmean,\n\t\t\tcount,\n\t\t\tstd,\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tmad,\n\t\t\tq1,\n\t\t\tq3,\n\t\t\tiqr\n\t\t};\n\t\treturn stats;\n\t}\n\tdataQuality() {\n\t\tlet count = this.count();\n\t\tlet valid = this.getSeries(\"flag\")\n\t\t\t.where(\n\t\t\t\tvalue =>\n\t\t\t\t\tvalue === null ||\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t)\n\t\t\t.count();\n\t\tlet missing = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"missing\") !== -1)\n\t\t\t.count();\n\t\tlet invalid = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"outlier\") !== -1)\n\t\t\t.count();\n\t\tlet zeroFill = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"zeroFill\") !== -1)\n\t\t\t.count();\n\t\tlet breakdown = {\n\t\t\tvalid: valid / count,\n\t\t\tmissing: missing / count,\n\t\t\tinvalid: invalid / count\n\t\t};\n\t\tlet report = {\n\t\t\taccuracy: 0,\n\t\t\tcompleteness: 0,\n\t\t\tconsistency: 0\n\t\t};\n\t\treturn {};\n\t}\n\t// Chainable Methods\n\ttransformAll(adjustmentFunction = v => v, columns) {\n\t\tlet df = this;\n\t\tif (!columns) {\n\t\t\tcolumns = df\n\t\t\t\t.detectTypes()\n\t\t\t\t.where(row => row.Type === \"number\")\n\t\t\t\t.distinct(row => row.Column)\n\t\t\t\t.getSeries(\"Column\")\n\t\t\t\t.toArray();\n\t\t}\n\t\tcolumns.forEach(col => {\n\t\t\tdf = df.transformSeries({\n\t\t\t\t[col]: value => {\n\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\tremoveOutliers({ lowerThreshold, upperThreshold } = {}) {\n\t\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\t\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\t\tvalue < lowerThreshold || value > upperThreshold;\n\t\tlet df = this.generateSeries({\n\t\t\traw: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? row.value\n\t\t\t\t\t: null,\n\t\t\tflag: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? [\"outlier\"]\n\t\t\t\t\t: null\n\t\t}).transformSeries({\n\t\t\tvalue: value =>\n\t\t\t\toutlierCheck(value, lowerThreshold, upperThreshold) ? null : value\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\treset() {\n\t\treturn this.withSeries({\n\t\t\tvalue: row => (row.raw && !isNaN(row.raw) ? row.raw : row.value)\n\t\t}).dropSeries([\"flag\", \"raw\"]);\n\t}\n\tgroup(interval, toArray) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\t\tlet groups = this.groupBy(dateComparison);\n\t\treturn groups;\n\t}\n\t// Not Working Yet, downsample and upsample independently work\n\tresample([duration, value = 1], fillType) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet interval = this.interval;\n\t\tif (isEqual(interval, [duration, value])) {\n\t\t\treturn this;\n\t\t}\n\t\tlet d0 = dayjs(0);\n\t\tlet currentSampleDiff = dayjs(0)\n\t\t\t.add(interval[1], interval[0])\n\t\t\t.diff(d0);\n\t\tlet newSampleDiff = dayjs(0)\n\t\t\t.add(value, duration)\n\t\t\t.diff(d0);\n\t\tif (currentSampleDiff < newSampleDiff) {\n\t\t\treturn this.downsample([duration, value], fillType);\n\t\t} else {\n\t\t\treturn this.upsample([duration, value], fillType);\n\t\t}\n\t}\n\tupsample([duration, value], fillType = \"avg\") {\n\t\t// Dont use this b/c it has the raw and flag values\n\t\tlet df = this.fillGaps(\n\t\t\tgapExists([duration, value]),\n\t\t\tgapFill(fillType, [duration, value])\n\t\t);\n\t\treturn new Timeseries(df);\n\t}\n\tdownsample([duration, value], fillType = \"sum\") {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t\t}\n\t\tlet dateComparison = row => row.date.startOf(duration);\n\t\tlet valueColumns = this.valueColumns;\n\t\tif (value) {\n\t\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t\t}\n\n\t\tlet df = this.groupBy(dateComparison)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\t\treturn {\n\t\t\t\t\tdate,\n\t\t\t\t\t...fromPairs([\n\t\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...group\n\t\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t])\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.withIndex(row => dayjs(row.date).toDate());\n\t\treturn new Timeseries(df);\n\t}\n\n\tpopulate(value, type = \"avg\") {\n\t\tlet v;\n\t\tswitch (type) {\n\t\t\tcase \"fill\":\n\t\t\t\tv = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = value / this.getIndex().count();\n\t\t\t\tbreak;\n\t\t}\n\t\tlet df = this.generateSeries({ value: row => v });\n\t\treturn new Timeseries(df);\n\t}\n\tfill(interval, fillType) {\n\t\t// let interval = this.interval;\n\t\tif (!interval || !Array.isArray(interval)) interval = this.interval;\n\t\tlet ndf = this.fillGaps(gapExists(interval), gapFill(fillType, interval));\n\t\treturn new Timeseries(ndf);\n\t}\n\treduceToValue(columnNames) {\n\t\tfunction chooseValue(row, columnNames = []) {\n\t\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\t\treturn values[0] || 0;\n\t\t}\n\t\tlet df = this.generateSeries({\n\t\t\tvalue: row => chooseValue(row, columnNames)\n\t\t}).subset([\"date\", \"value\"]);\n\t\treturn new Timeseries(df);\n\t}\n\tclean(columnName = \"value\", { lowerThreshold, upperThreshold }) {\n\t\tlet arr = this.toArray().map(row => {\n\t\t\tlet value = row[columnName];\n\t\t\tif (value > upperThreshold || value < lowerThreshold) {\n\t\t\t\treturn { ...row, value: undefined, raw: value };\n\t\t\t} else {\n\t\t\t\treturn row;\n\t\t\t}\n\t\t});\n\t\treturn new Timeseries(arr);\n\t}\n\t// Static Methods\n\tstatic blank(startDate, endDate, [duration, value = 1]) {\n\t\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\t\tconsole.error(interval);\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\t}\n\t\tlet df = new Timeseries([\n\t\t\t{ date: dayjs(startDate) },\n\t\t\t{ date: dayjs(endDate) }\n\t\t])\n\t\t\t.fillGaps(gapExists([duration, value]), gapFillBlank([duration, value]))\n\t\t\t.between(startDate, endDate);\n\t\treturn new Timeseries(df);\n\t}\n\tstatic aggregate(dataframes) {\n\t\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\t\tdataframes = dataframes.map(df => new Timeseries(df));\n\t\tconst concatenated = DataFrame.concat(dataframes)\n\t\t\t.groupBy(row => row.date)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date;\n\t\t\t\tlet o = { date };\n\t\t\t\tgroup\n\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t.filter(c => c !== \"date\")\n\t\t\t\t\t.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\t\treturn o;\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.toArray();\n\t\treturn new Timeseries(concatenated);\n\t}\n\t// Models\n\tannualMonthlyAverage({ startDate, endDate }) {\n\t\tlet months = this.downsample([\"month\", 1], \"sum\").between(\n\t\t\tstartDate,\n\t\t\tendDate\n\t\t);\n\t\tlet avg = months.getSeries(\"value\").average();\n\t}\n\t// Building Functions\n\tannualIntensity(normalizeValue = 1) {\n\t\tlet interval = this.interval;\n\t\tlet annual = this.groupBy(row => row.date.year())\n\t\t\t.select(group => {\n\t\t\t\tlet startDate = group.first().date;\n\t\t\t\tlet endDate = group\n\t\t\t\t\t.last()\n\t\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\t\treturn {\n\t\t\t\t\tstartDate,\n\t\t\t\t\tendDate,\n\t\t\t\t\t...fromPairs(\n\t\t\t\t\t\tthis.valueColumns.map(col => [\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.renameSeries({ startDate: \"date\" })\n\t\t\t.dropSeries(\"endDate\");\n\t\treturn new Timeseries(annual);\n\t}\n}\nexport default Timeseries;\n"],"names":["gapExists","duration","durationValue","pairA","pairB","startDate","Math","floor","dayjs","diff","valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","gapFill","endDate","newEntries","adjustment","add","toDate","e","valueOf","Object","assign","push","Timeseries","data","DataFrame","toArray","config","values","others","sort","a","b","index","considerAllRows","dateRange","unit","start","this","first","end","last","startOf","endOf","at","calculateThresholds","k","filterZeros","noflags","where","row","Array","isArray","length","isNaN","getSeries","count","min","esd","rosnerTest","thresholds","box","boxPlotTest","modz","modifiedZScoreTest","calculateStatistics","filterNegative","series","deflate","columnName","median","mean","average","std","max","mad","medianAbsoluteDeviation","q1","quantile","q3","iqr","dataQuality","transformAll","adjustmentFunction","columns","v","df","detectTypes","Type","distinct","Column","forEach","col","transformSeries","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","generateSeries","raw","reset","withSeries","dropSeries","group","interval","groupBy","resample","isEqual","d0","downsample","upsample","fillGaps","dateComparison","valueColumns","select","sum","getColumnNames","filter","inflate","withIndex","populate","type","getIndex","fill","reduceToValue","columnNames","n","chooseValue","subset","clean","undefined","blank","console","error","gapFillBlank","between","aggregate","dataframes","concat","o","c","annualMonthlyAverage","annualIntensity","normalizeValue","year","scaler","_this2","renameSeries","ms","window","detectValues","orderBy","Frequency","Value","log","ceil"],"mappings":"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"}
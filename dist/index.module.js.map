{"version":3,"file":"index.module.js","sources":["../src/lib/Timeseries.interval.js","../src/lib/Timeseries.fill.js","../src/lib/Timeseries.statistics.js","../src/index.js"],"sourcesContent":["import dayjs from \"dayjs\";\n\nconst msToInterval = ms => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(ms);\n\tif (end.diff(start, \"month\", true) >= 11) {\n\t\treturn [\"year\", Math.ceil(end.diff(start, \"year\", true))];\n\t} else if (end.diff(start, \"day\", true) >= 28) {\n\t\treturn [\"month\", Math.ceil(end.diff(start, \"month\", true))];\n\t} else if (end.diff(start, \"hour\", true) >= 23) {\n\t\treturn [\"day\", Math.ceil(end.diff(start, \"day\", true))];\n\t} else if (end.diff(start, \"minute\", true) >= 55) {\n\t\treturn [\"hour\", Math.ceil(end.diff(start, \"hour\", true))];\n\t} else {\n\t\treturn [\"minute\", end.diff(start, \"minute\")];\n\t}\n};\nconst intervalToMS = ([unit, value]) => {\n\tlet start = dayjs();\n\tlet end = dayjs().add(value, unit);\n\treturn end.diff(start);\n};\nfunction calculateInterval(df, startDate, endDate) {\n\tif (!startDate) startDate = df.first.date;\n\tif (!endDate) endDate = df.last.date;\n\tfunction computeInterval(window) {\n\t\treturn window.last() - window.first();\n\t}\n\tconst intervals = df\n\t\t.between(startDate, endDate)\n\t\t.getIndex()\n\t\t.window(2)\n\t\t.select(computeInterval)\n\t\t.detectValues()\n\t\t.orderBy(row => row.Frequency);\n\n\tlet val = intervals.last().Value;\n\treturn msToInterval(val);\n}\nexport { msToInterval, intervalToMS, calculateInterval };\n","import dayjs from \"dayjs\";\nimport fromPairs from \"lodash/fromPairs\";\nimport toPairs from \"lodash/toPairs\";\nconst gapExists = ([duration, durationValue = 1]) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration, true) / durationValue\n\t);\n\n\tif (gapSize > 0) return true;\n\treturn false;\n};\nconst gapExists_old = (interval, maxGap) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize;\n\tif (interval === \"quarterHour\") {\n\t\tgapSize = Math.floor(dayjs(endDate).diff(startDate, \"minutes\") / 15);\n\t} else {\n\t\tgapSize = dayjs(endDate).diff(startDate, interval);\n\t}\n\tif (maxGap && maxGap > gapSize) return false;\n\tif (gapSize > 0) return true;\n\treturn false;\n};\n\nconst gapFillNull = ([duration, durationValue], flag) => (pairA, pairB) => {\n\tconst startDate = pairA[0];\n\tconst endDate = pairB[0];\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst newEntries = [];\n\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet date = dayjs(startDate).add((entryIndex + 1) * durationValue, duration);\n\t\tnewEntries.push([\n\t\t\tdate.valueOf(),\n\t\t\t{ date, value: undefined, ...(flag && { flag: [flag] }) }\n\t\t]);\n\t}\n\treturn newEntries;\n};\nconst gapFillBlank = gapFillNull;\n\nconst valueFiller = (\n\tfillType,\n\t{ startValue, endValue, entryIndex, numEntries },\n\t{ overrideValue, dateFunction, date, flag }\n) => {\n\tif (\n\t\t[\"pad\", \"interpolate\", \"average\", \"dateFunction\", \"value\"].indexOf(\n\t\t\tfillType\n\t\t) === -1\n\t) {\n\t\tthrow new Error(\"fill Type not supported\");\n\t}\n\tlet value;\n\tif (fillType === \"pad\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, startValue[key]];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", \"pad\"];\n\t} else if (fillType === \"interpolate\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv =\n\t\t\t\t\tstartValue[key] +\n\t\t\t\t\t(entryIndex + 1) *\n\t\t\t\t\t\t((endValue[key] - startValue[key]) / (numEntries + 1));\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"average\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = (startValue[key] + endValue[key]) / numEntries;\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"dateFunction\" && dateFunction) {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv = dateFunction(date);\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else if (fillType === \"value\") {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\tlet nv;\n\t\t\t\tif (typeof overrideValue === \"number\") {\n\t\t\t\t\tnv = overrideValue;\n\t\t\t\t} else {\n\t\t\t\t\tnv = overrideValue[key];\n\t\t\t\t}\n\t\t\t\treturn [key, nv];\n\t\t\t})\n\t\t);\n\t\tflag = flag ? flag : [\"fill\", fillType];\n\t} else {\n\t\tvalue = fromPairs(\n\t\t\ttoPairs(startValue).map(([key, val]) => {\n\t\t\t\treturn [key, null];\n\t\t\t})\n\t\t);\n\t\tflag = [\"fill\"];\n\t}\n\treturn { ...value, flag };\n};\n\nconst gapFill = (\n\tfillType,\n\t[duration, durationValue],\n\t{ overrideValue, dateFunction, flag } = {}\n) => (pairA, pairB) => {\n\t// Fill values forward.\n\n\tconst startDate = dayjs(pairA[0]);\n\tconst endDate = dayjs(pairB[0]);\n\tlet gapSize = Math.floor(\n\t\tdayjs(endDate).diff(startDate, duration) / durationValue\n\t);\n\tconst numEntries = gapSize - 1;\n\tconst startValue = pairA[1];\n\tconst endValue = pairB[1];\n\tconst newEntries = [];\n\tfor (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {\n\t\tlet adjustment = valueFiller(\n\t\t\t\tfillType,\n\t\t\t\t{ startValue, endValue, entryIndex, numEntries },\n\t\t\t\t{\n\t\t\t\t\toverrideValue,\n\t\t\t\t\tdateFunction,\n\t\t\t\t\tflag\n\t\t\t\t}\n\t\t\t),\n\t\t\tdate = dayjs(startDate)\n\t\t\t\t.add((entryIndex + 1) * durationValue, duration)\n\t\t\t\t.toDate();\n\t\tlet e = [date.valueOf(), Object.assign({}, adjustment, { date })];\n\t\tnewEntries.push(e);\n\t}\n\n\treturn newEntries;\n};\n\nexport { gapExists, gapFill, gapFillBlank, gapFillNull, valueFiller };\n","// Source: https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm\n// https://vsp.pnnl.gov/help/Vsample/Rosners_Outlier_Test.htm\n// https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm\n// https://www.math.ucla.edu/~tom/distributions/KolSmir2.html?\nimport { DataFrame } from \"data-forge\";\nimport {\n  sampleStandardDeviation,\n  mean as _mean,\n  max,\n  median as _median,\n  medianAbsoluteDeviation,\n  quantile\n} from \"simple-statistics\";\nimport { Studentt } from \"distributions\";\nimport dayjs from \"dayjs\";\nfunction rval(df) {\n  let values = df.deflate(row => row.x).toArray();\n  let std = sampleStandardDeviation(values);\n  let mean = _mean(values);\n  if (std === 0) {\n    let ndf = df.generateSeries({ ares: row => 0 });\n    return { R: 0, std, mean, df: ndf };\n  }\n  let ndf = new DataFrame({\n    values: values.map(x => ({\n      x,\n      ares: Math.abs(x - mean) / std\n    }))\n  });\n  let R = max(ndf.deflate(row => row.ares).toArray());\n  return { R, df: ndf, std, mean };\n}\n\nfunction pValue(n, i, alpha) {\n  let p = 1 - alpha / (2 * (n - i + 1));\n  return p;\n}\nfunction tValue(p, degreeOfFreedom) {\n  let qt = new Studentt(degreeOfFreedom);\n  let t = qt.inv(p);\n  return t;\n}\n//\nfunction lambdaTest(n, i, alpha) {\n  let p = pValue(n, i, alpha);\n  let df = n - i - 1;\n  let t = tValue(p, df);\n  let lambda =\n    (t * (n - i)) /\n    Math.sqrt((n - i - 1 + Math.pow(t, 2)) * (n - i + 1));\n  return { lambda, p, t };\n}\nfunction rosnerTest(dataset = [], k = 10, alpha = 0.05) {\n  let dataframe = new DataFrame({\n    values: dataset.map(x => ({ x }))\n  });\n  let n = dataframe.getSeries(\"x\").count();\n  let newdf;\n  let i = 1;\n  let outliers = [];\n  let trip = false;\n  while (i <= k) {\n    let pair = {};\n    let s = Date.now();\n    if (i === 1) {\n      let { R, df, mean, std } = rval(dataframe);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    } else {\n      let { R, df, mean, std } = rval(newdf);\n      newdf = df.where(row => row.ares !== R);\n      pair = Object.assign({}, pair, {\n        mean,\n        std,\n        Value: df\n          .where(row => row.ares === R)\n          .getSeries(\"x\")\n          .first(),\n        R\n      });\n    }\n    let { lambda, p, t } = lambdaTest(n, i, alpha);\n    pair = Object.assign({}, pair, { lambda });\n    outliers.push(pair);\n    if (trip && pair.R > pair.lambda) trip = false;\n    if (pair.R === 0) break;\n    if (pair.R < pair.lambda) {\n      if (trip) {\n        break;\n      } else {\n        trip = true;\n      }\n    }\n    i++;\n  }\n  outliers = new DataFrame(outliers)\n    .generateSeries({\n      outlier: row => row.R > row.lambda\n    })\n    .takeWhile(row => row.outlier);\n  let outlierValues = outliers\n    .where(row => row.Value > 0)\n    .deflate(row => row.Value);\n  let thresholds = {\n    lower: 0,\n    upper:\n      outlierValues.count() > 0 ? outlierValues.min() : Infinity\n  };\n  return {\n    outliers,\n    thresholds,\n    iterations: i\n  };\n}\nconst modz = (value, mad, median) => {\n  return (0.6745 * (value - median)) / mad;\n};\nfunction modifiedZScoreTest(values) {\n  let median = _median(values);\n  let mad = medianAbsoluteDeviation(values);\n  values = values\n    .sort((a, b) => b - a)\n    .filter(v => v > 0)\n    .map(v => [v, modz(v, mad, median)]);\n  let outliers = values.filter(\n    ([v, modz]) => Math.abs(modz) >= 3.5\n  );\n  let upper = Math.min(\n    ...[Infinity, ...outliers.map(v => v[0])]\n  );\n  // let score,\n  // \tvalue,\n  // \tthreshold = Infinity,\n  // \tindex = 0;\n  // do {\n  // \tvalue = values[index];\n  // \tscore = modz(value, mad, median);\n  // \tif (Math.abs(score) >= 3.5) threshold = value;\n  // } while (score >= 3.5);\n  return { thresholds: { upper, lower: 0 } };\n}\nfunction boxPlotTest(values) {\n  let q1 = quantile(values, 0.25);\n  let q3 = quantile(values, 0.75);\n  let iqr = q3 - q1;\n  return {\n    thresholds: {\n      lowerInner: q1 - 1.5 * iqr,\n      upperInner: q1 - 3 * iqr,\n      lowerOuter: q3 + 1.5 * iqr,\n      upperOuter: q3 + 3 * iqr\n    }\n  };\n}\nfunction calculateOutlierThresholds(\n  df,\n  { k, filterZeros = true } = {}\n) {\n  let values = df\n    .where(\n      row =>\n        row.flag === null ||\n        row.flag === undefined ||\n        Array.isArray(row.flag)\n    )\n    .where(row => !isNaN(row.value) && row.value !== null)\n    .getSeries(\"value\")\n    .bake();\n  if (filterZeros) values = values.where(value => value > 0);\n  if (!k) {\n    k =\n      values.count() < 1000\n        ? Math.floor(values.count() * 0.15)\n        : Math.min(...[1000, Math.floor(values.count() * 0.02)]);\n  }\n  if (values.count < 5) return {};\n  let { outliers, threshold } = rosnerTest(values.toArray(), k);\n  return { outliers, threshold };\n}\n\nfunction zeroCheck(df, threshold = 2) {\n  let zeroGroups = df\n    .variableWindow((a, b) => {\n      return a.value === b.value && a.value === 0;\n    })\n    .where(window => window.getIndex().count() >= threshold);\n  let zeroSummary = zeroGroups\n    .select(window => ({\n      start: window.first().date,\n      end: window.last().date,\n      count: window.count()\n    }))\n    .inflate(); // Series -> dataframe.\n  // .toArray()\n  return { zeroSummary, zeroGroups };\n}\n\nfunction zeroReplacement(df, threshold) {\n  let { zeroGroups } = zeroCheck(df, threshold);\n  zeroGroups.forEach(dff => {\n    dff = dff.transformSeries({\n      value: value => null,\n      flag: value => [\"zero\"]\n    });\n    df = DataFrame.merge([df, dff]);\n  });\n  return df;\n}\nfunction isOutlier(value, { lower, upper }) {\n  if (value < lower || value >= upper) {\n    return true;\n  }\n  return false;\n}\nfunction validMean(df) {\n  let values = df\n    .getSeries(\"value\")\n    .where(value => typeof value === \"number\");\n  return values.average();\n}\nfunction validMonthlyMeanMap(df) {\n  let dateComparison = row =>\n    dayjs(row.date)\n      .startOf(\"month\")\n      .month();\n\n  df = df\n    .where(row => typeof row.value === \"number\")\n    .groupBy(dateComparison)\n    .select(group => ({\n      month: new Date(group.first().date).getMonth(),\n      value: group.deflate(row => row.value).average()\n    }));\n  return new Map(\n    df.toArray().map(({ month, value }) => [month, value])\n  );\n}\n\nfunction quality(df) {\n  let count = df.getIndex().count();\n  let valid = df\n    .getSeries(\"flag\")\n    .where(\n      value =>\n        value === null ||\n        (Array.isArray(value) && value.length === 0)\n    )\n    .count();\n  let missing = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"missing\") !== -1)\n    .count();\n  let dirty = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"clean\") !== -1)\n    .count();\n  let zerod = df\n    .getSeries(\"flag\")\n    .where(value => Array.isArray(value))\n    .where(value => value.indexOf(\"zero\") !== -1)\n    .count();\n  let breakdown = {\n    valid: valid / count,\n    missing: missing / count,\n    invalid: (dirty + zerod) / count\n  };\n  let report = {\n    accuracy: (1 - dirty / count) * 4,\n    completeness: 4 * breakdown.valid,\n    consistency: 4 * ((count - missing - zerod) / count)\n  };\n  return { breakdown, report, count };\n}\n\nexport {\n  rosnerTest,\n  modifiedZScoreTest,\n  boxPlotTest,\n  calculateOutlierThresholds,\n  zeroReplacement,\n  isOutlier,\n  validMean,\n  validMonthlyMeanMap,\n  quality\n};\n","import { DataFrame } from \"data-forge\";\nimport dayjs from \"dayjs\";\n// const isBetween = require('dayjs/plugin/isBetween')\nimport { msToInterval, intervalToMS } from \"./lib/Timeseries.interval\";\nimport isEqual from \"lodash/isEqual\";\nimport has from \"lodash/has\";\nimport fromPairs from \"lodash/fromPairs\";\nimport { gapExists, gapFill, gapFillBlank } from \"./lib/Timeseries.fill\";\nimport { medianAbsoluteDeviation, quantile } from \"simple-statistics\";\nimport {\n\trosnerTest,\n\tboxPlotTest,\n\tmodifiedZScoreTest\n} from \"./lib/Timeseries.statistics\";\nconst annualScale = (start, end) => 365 / dayjs(end).diff(dayjs(start), \"day\");\nconst calculateChange = (baseline, value) => (value - baseline) / baseline;\n\nclass Timeseries extends DataFrame {\n\tconstructor(data = []) {\n\t\tif (data instanceof Timeseries) return data;\n\t\tif (data instanceof DataFrame) {\n\t\t\tdata = data.toArray();\n\t\t}\n\t\t// sort\n\t\tdata = data\n\t\t\t.map(({ date, ...others }) => ({ date: dayjs(date), ...others }))\n\t\t\t.sort((a, b) => a.date.valueOf() - b.date.valueOf());\n\t\tlet config = {\n\t\t\tvalues: data,\n\t\t\tindex: data.map(({ date }) => date.toDate()),\n\t\t\tconsiderAllRows: true\n\t\t};\n\t\tsuper(config);\n\t}\n\tget interval() {\n\t\tfunction computeInterval(window) {\n\t\t\treturn window.last() - window.first();\n\t\t}\n\t\tconst intervals = this.getIndex()\n\t\t\t.window(2)\n\t\t\t.select(computeInterval)\n\t\t\t.detectValues()\n\t\t\t.orderBy(row => -row.Frequency)\n\t\t\t.orderBy(row => row.Value);\n\t\t// console.log(intervals.toString());\n\t\tlet val = intervals.first().Value;\n\t\treturn msToInterval(val);\n\t}\n\tget valueColumns() {\n\t\treturn this.detectTypes()\n\t\t\t.where(row => row.Type === \"number\")\n\t\t\t.distinct(row => row.Column)\n\t\t\t.getSeries(\"Column\")\n\t\t\t.toArray();\n\t}\n\tdateRange(unit, adjustment) {\n\t\tlet start = dayjs(this.first().date),\n\t\t\tend = dayjs(this.last().date);\n\t\tif (adjustment) {\n\t\t\tstart = start.startOf(adjustment);\n\t\t\tend = end.endOf(adjustment);\n\t\t}\n\t\treturn end.diff(start, unit);\n\t}\n\tat(date) {\n\t\treturn super.at(dayjs(date));\n\t}\n\tcalculateThresholds({ k, filterZeros = true, filterNegative = true } = {}) {\n\t\tlet noflags = this.where(\n\t\t\trow =>\n\t\t\t\trow.flag === null ||\n\t\t\t\trow.flag === undefined ||\n\t\t\t\t(Array.isArray(row.flag) && row.flag.length === 0)\n\t\t)\n\t\t\t.where(row => !isNaN(row.value) && row.value !== null)\n\t\t\t.getSeries(\"value\");\n\t\tif (filterZeros) noflags = noflags.where(value => value !== 0);\n\t\tif (filterNegative) noflags = noflags.where(value => value > 0);\n\t\tif (!k) {\n\t\t\tk =\n\t\t\t\tnoflags.count() < 1000\n\t\t\t\t\t? Math.floor(noflags.count() * 0.15)\n\t\t\t\t\t: Math.min(...[1000, Math.floor(noflags.count() * 0.02)]);\n\t\t}\n\t\tif (noflags.count() < 5) return {};\n\t\tlet { thresholds: esd } = rosnerTest(noflags.toArray(), k);\n\t\tlet { thresholds: box } = boxPlotTest(noflags.toArray());\n\t\tlet { thresholds: modz } = modifiedZScoreTest(noflags.toArray());\n\t\treturn { esd, box, modz };\n\t}\n\tcalculateStatistics({\n\t\tcolumn = \"value\",\n\t\tfilterZeros = false,\n\t\tfilterNegative = true\n\t} = {}) {\n\t\tlet series = this.deflate(row => row[column]).where(value => !isNaN(value));\n\t\tif (filterNegative) series = series.where(value => value >= 0);\n\t\tif (filterZeros) series = series.where(value => value !== 0);\n\t\tlet median = series.median();\n\t\tlet mean = series.average();\n\t\tlet count = series.count();\n\t\tlet std = series.std();\n\t\tlet min = series.min();\n\t\tlet max = series.max();\n\t\tlet mad = medianAbsoluteDeviation(series.toArray());\n\t\tlet q1 = quantile(series.toArray(), 0.25);\n\t\tlet q3 = quantile(series.toArray(), 0.75);\n\t\tlet iqr = q3 - q1;\n\t\tlet stats = {\n\t\t\tmedian,\n\t\t\tmean,\n\t\t\tcount,\n\t\t\tstd,\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tmad,\n\t\t\tq1,\n\t\t\tq3,\n\t\t\tiqr\n\t\t};\n\t\treturn stats;\n\t}\n\tdataQuality() {\n\t\tlet count = this.count();\n\t\tlet valid = this.getSeries(\"flag\")\n\t\t\t.where(\n\t\t\t\tvalue =>\n\t\t\t\t\tvalue === null ||\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(Array.isArray(value) && value.length === 0)\n\t\t\t)\n\t\t\t.count();\n\t\tlet missing = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"missing\") !== -1)\n\t\t\t.count();\n\t\tlet invalid = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"outlier\") !== -1)\n\t\t\t.count();\n\t\tlet zeroFill = this.getSeries(\"flag\")\n\t\t\t.where(value => Array.isArray(value))\n\t\t\t.where(value => value.indexOf(\"zeroFill\") !== -1)\n\t\t\t.count();\n\t\tlet breakdown = {\n\t\t\tvalid: valid / count,\n\t\t\tmissing: missing / count,\n\t\t\tinvalid: invalid / count\n\t\t};\n\t\tlet report = {\n\t\t\taccuracy: 0,\n\t\t\tcompleteness: 0,\n\t\t\tconsistency: 0\n\t\t};\n\t\treturn {};\n\t}\n\t// Chainable Methods\n\ttransformAll(adjustmentFunction = v => v, columns) {\n\t\tlet df = this;\n\t\tif (!columns) {\n\t\t\tcolumns = df\n\t\t\t\t.detectTypes()\n\t\t\t\t.where(row => row.Type === \"number\")\n\t\t\t\t.distinct(row => row.Column)\n\t\t\t\t.getSeries(\"Column\")\n\t\t\t\t.toArray();\n\t\t}\n\t\tcolumns.forEach(col => {\n\t\t\tdf = df.transformSeries({\n\t\t\t\t[col]: value => {\n\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn adjustmentFunction(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\tremoveOutliers({ lowerThreshold, upperThreshold } = {}) {\n\t\tif (lowerThreshold > upperThreshold) throw new Error(\"thresholds invalid\");\n\t\tlet outlierCheck = (value, lowerThreshold, upperThreshold) =>\n\t\t\tvalue < lowerThreshold || value > upperThreshold;\n\t\tlet df = this.generateSeries({\n\t\t\traw: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? row.value\n\t\t\t\t\t: null,\n\t\t\tflag: row =>\n\t\t\t\toutlierCheck(row.value, lowerThreshold, upperThreshold)\n\t\t\t\t\t? [\"outlier\"]\n\t\t\t\t\t: null\n\t\t}).transformSeries({\n\t\t\tvalue: value =>\n\t\t\t\toutlierCheck(value, lowerThreshold, upperThreshold) ? null : value\n\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\treset() {\n\t\treturn this.withSeries({\n\t\t\tvalue: row => (row.raw && !isNaN(row.raw) ? row.raw : row.value)\n\t\t}).dropSeries([\"flag\", \"raw\"]);\n\t}\n\tgroup(interval, toArray) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(interval) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet dateComparison = row => dayjs(row.date).startOf(interval);\n\t\tlet groups = this.groupBy(dateComparison);\n\t\treturn groups;\n\t}\n\t// Not Working Yet, downsample and upsample independently work\n\tresample([duration, value = 1], fillType) {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tlet interval = this.interval;\n\t\tif (isEqual(interval, [duration, value])) {\n\t\t\treturn this;\n\t\t}\n\t\tlet d0 = dayjs(0);\n\t\tlet currentSampleDiff = dayjs(0)\n\t\t\t.add(interval[1], interval[0])\n\t\t\t.diff(d0);\n\t\tlet newSampleDiff = dayjs(0)\n\t\t\t.add(value, duration)\n\t\t\t.diff(d0);\n\t\tif (currentSampleDiff < newSampleDiff) {\n\t\t\treturn this.downsample([duration, value], fillType);\n\t\t} else {\n\t\t\treturn this.upsample([duration, value], fillType);\n\t\t}\n\t}\n\tupsample([duration, value], fillType = \"avg\") {\n\t\t// Dont use this b/c it has the raw and flag values\n\t\tlet df = this.fillGaps(\n\t\t\tgapExists([duration, value]),\n\t\t\tgapFill(fillType, [duration, value])\n\t\t);\n\t\treturn new Timeseries(df);\n\t}\n\tdownsample([duration, value], fillType = \"sum\") {\n\t\tif ([\"hour\", \"day\", \"month\", \"year\"].indexOf(duration) === -1)\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\tif ([\"sum\", \"avg\", \"median\"].indexOf(fillType) === -1) {\n\t\t\tthrow new Error(\"aggregation type not suppported, only:\");\n\t\t}\n\t\tlet dateComparison = row => row.date.startOf(duration);\n\t\tlet valueColumns = this.valueColumns;\n\t\tif (value) {\n\t\t\tdateComparison = row => row.date.startOf(duration).add(value, duration);\n\t\t}\n\n\t\tlet df = this.groupBy(dateComparison)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date.startOf(duration);\n\t\t\t\treturn {\n\t\t\t\t\tdate,\n\t\t\t\t\t...fromPairs([\n\t\t\t\t\t\t...valueColumns.map(col => {\n\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\tswitch (fillType) {\n\t\t\t\t\t\t\t\tcase \"median\":\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.median();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"avg\":\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.average();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// sum\n\t\t\t\t\t\t\t\t\tvalue = group\n\t\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t\t\t.sum();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...group\n\t\t\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t\t\t.filter(col => col !== \"date\")\n\t\t\t\t\t\t\t.filter(col => valueColumns.indexOf(col) === -1)\n\t\t\t\t\t\t\t.map(col => {\n\t\t\t\t\t\t\t\tlet value = group\n\t\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t\t.distinct()\n\t\t\t\t\t\t\t\t\t.toArray();\n\t\t\t\t\t\t\t\tif (value.length === 1) value = value[0];\n\t\t\t\t\t\t\t\treturn [col, value];\n\t\t\t\t\t\t\t})\n\t\t\t\t\t])\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.withIndex(row => dayjs(row.date).toDate());\n\t\treturn new Timeseries(df);\n\t}\n\n\tpopulate(value, type = \"avg\") {\n\t\tlet v;\n\t\tswitch (type) {\n\t\t\tcase \"fill\":\n\t\t\t\tv = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = value / this.getIndex().count();\n\t\t\t\tbreak;\n\t\t}\n\t\tlet df = this.generateSeries({ value: row => v });\n\t\treturn new Timeseries(df);\n\t}\n\t// fill(interval, fillType) {\n\t// \t// let interval = this.interval;\n\t// \tif (!interval || !Array.isArray(interval)) interval = this.interval;\n\t// \tlet ndf = this.fillGaps(gapExists(interval), gapFill(fillType, interval));\n\t// \treturn new Timeseries(ndf);\n\t// }\n\tfill() {\n\t\tlet startDate = this.first().date.toDate(),\n\t\t\tendDate = this.last().date.toDate();\n\t\tlet interval = this.interval;\n\t\tconsole.time(\"blank\");\n\t\tlet bdf = Timeseries.blank(startDate, endDate, interval, \"missing\");\n\t\tconsole.timeEnd(\"blank\");\n\t\tconsole.time(\"join\");\n\t\tlet df = this.joinOuterRight(\n\t\t\tbdf,\n\t\t\torigional => origional.date.valueOf(),\n\t\t\tblank => blank.date.valueOf(),\n\t\t\t(data, fill) => {\n\t\t\t\tif (data) {\n\t\t\t\t\treturn data;\n\t\t\t\t} else {\n\t\t\t\t\treturn fill;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// let df = this.zip(bdf, (data, fill) => {\n\t\t// \tif (data) {\n\t\t// \t\treturn data;\n\t\t// \t} else {\n\t\t// \t\treturn fill;\n\t\t// \t}\n\t\t// });\n\t\tconsole.timeEnd(\"join\");\n\t\tconsole.time(\"new timeseries\");\n\t\t// df = new Timeseries(df);\n\t\tconsole.timeEnd(\"new timeseries\");\n\t\treturn df;\n\t}\n\treduceToValue(columnNames) {\n\t\tfunction chooseValue(row, columnNames = []) {\n\t\t\tlet values = columnNames.map(n => row[n]).filter(v => v);\n\t\t\treturn values[0] || 0;\n\t\t}\n\t\tlet df = this.generateSeries({\n\t\t\tvalue: row => chooseValue(row, columnNames)\n\t\t}).subset([\"date\", \"value\"]);\n\t\treturn new Timeseries(df);\n\t}\n\tclean(columnName = \"value\", { lowerThreshold, upperThreshold }) {\n\t\tlet arr = this.toArray().map(row => {\n\t\t\tif (row.value > upperThreshold || row.value < lowerThreshold) {\n\t\t\t\tlet { value, flag = [], ...others } = row;\n\t\t\t\tif (!flag) flag = [];\n\t\t\t\tif (!Array.isArray(flag)) flag = [flag];\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\traw: value,\n\t\t\t\t\tflag: [\"outlier\", ...flag],\n\t\t\t\t\t...others\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn row;\n\t\t\t}\n\t\t});\n\t\treturn new Timeseries(arr);\n\t}\n\t// Static Methods\n\tstatic blank(startDate, endDate, [duration, value = 1], flag) {\n\t\tif ([\"minute\", \"hour\", \"day\", \"month\", \"year\"].indexOf(duration) < 0) {\n\t\t\tconsole.error(interval);\n\t\t\tthrow new Error(\"interval type not supported\");\n\t\t}\n\t\tstartDate = dayjs(startDate);\n\t\tendDate = dayjs(endDate);\n\t\tlet dates = [startDate];\n\t\tlet interval = intervalToMS([duration, value]);\n\t\twhile (dates[dates.length - 1].valueOf() < endDate.valueOf()) {\n\t\t\tdates.push(dayjs(dates[dates.length - 1]).add(value, duration));\n\t\t}\n\t\tlet df = new Timeseries(dates.map(date => ({ date })));\n\t\t// let df = new Timeseries([\n\t\t// \t{ date: dayjs(startDate) },\n\t\t// \t{ date: dayjs(endDate) }\n\t\t// ])\n\t\t// \t.fillGaps(gapExists([duration, value]), gapFillBlank([duration, value]))\n\t\t// \t.between(startDate, endDate);\n\t\tconsole.log(df.count());\n\t\tif (flag)\n\t\t\tdf = df.generateSeries({\n\t\t\t\tflag: row => [flag]\n\t\t\t});\n\t\treturn new Timeseries(df);\n\t}\n\tstatic aggregate(dataframes) {\n\t\tif (!Array.isArray(dataframes)) dataframes = [dataframes];\n\t\tdataframes = dataframes.map(df => new Timeseries(df));\n\t\tconst concatenated = DataFrame.concat(dataframes)\n\t\t\t.groupBy(row => row.date)\n\t\t\t.select(group => {\n\t\t\t\tconst date = group.first().date;\n\t\t\t\tlet o = { date };\n\t\t\t\tgroup\n\t\t\t\t\t.getColumnNames()\n\t\t\t\t\t.filter(c => c !== \"date\")\n\t\t\t\t\t.forEach(c => (o[c] = group.deflate(row => row[c]).sum()));\n\t\t\t\treturn o;\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.toArray();\n\t\treturn new Timeseries(concatenated);\n\t}\n\t// Models\n\tannualMonthlyAverage({ startDate, endDate }) {\n\t\tlet months = this.downsample([\"month\", 1], \"sum\").between(\n\t\t\tstartDate,\n\t\t\tendDate\n\t\t);\n\t\tlet avg = months.getSeries(\"value\").average();\n\t}\n\t// Building Functions\n\tannualIntensity(normalizeValue = 1) {\n\t\tlet interval = this.interval;\n\t\tlet annual = this.groupBy(row => row.date.year())\n\t\t\t.select(group => {\n\t\t\t\tlet startDate = group.first().date;\n\t\t\t\tlet endDate = group\n\t\t\t\t\t.last()\n\t\t\t\t\t.date.add(interval[1] || 1, interval[0] || \"month\");\n\t\t\t\tlet scaler = annualScale(startDate, endDate);\n\t\t\t\treturn {\n\t\t\t\t\tstartDate,\n\t\t\t\t\tendDate,\n\t\t\t\t\t...fromPairs(\n\t\t\t\t\t\tthis.valueColumns.map(col => [\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t(group\n\t\t\t\t\t\t\t\t.deflate(row => row[col])\n\t\t\t\t\t\t\t\t.where(v => v)\n\t\t\t\t\t\t\t\t.sum() *\n\t\t\t\t\t\t\t\tscaler) /\n\t\t\t\t\t\t\t\tnormalizeValue\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\t\t\t\t};\n\t\t\t})\n\t\t\t.inflate()\n\t\t\t.renameSeries({ startDate: \"date\" })\n\t\t\t.dropSeries(\"endDate\");\n\t\treturn new Timeseries(annual);\n\t}\n\taddBaselineDelta(baselineDF) {\n\t\t// Only Change in Year\n\t\tif (!(baselineDF instanceof Timeseries))\n\t\t\tbaselineDF = new Timeseries(baselineDF);\n\t\tlet dfwb;\n\t\tif (baselineDF.count() > 1) {\n\t\t\tlet interval = this.interval;\n\t\t\tlet baselineInterval = baselineDF.interval;\n\t\t\tif (!isEqual(interval, baselineInterval)) {\n\t\t\t\tconsole.error(interval, baselineInterval);\n\t\t\t\tthrow new Error(\"baseline and data intervals do not match\");\n\t\t\t}\n\t\t\tlet indexer;\n\t\t\tswitch (interval[0]) {\n\t\t\t\tcase \"day\":\n\t\t\t\t\tindexer = date => `${date.month()}-${date.date()}`;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"month\":\n\t\t\t\t\tindexer = date => date.month();\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tindexer = date => 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet indexedBaseline = baselineDF.withIndex(row => indexer(row.date));\n\t\t\tlet getBaselineValue = index => {\n\t\t\t\tlet at = indexedBaseline.at(index);\n\t\t\t\tif (at && has(at, \"value\")) {\n\t\t\t\t\treturn at.value;\n\t\t\t\t} else {\n\t\t\t\t\treturn indexedBaseline.getSeries(\"value\").average();\n\t\t\t\t}\n\t\t\t};\n\t\t\tdfwb = this.generateSeries({\n\t\t\t\tbaseline: row => getBaselineValue(indexer(row.date))\n\t\t\t});\n\t\t} else {\n\t\t\tdfwb = this.generateSeries({\n\t\t\t\tbaseline: row => baselineDF.first().value\n\t\t\t});\n\t\t}\n\t\tdfwb = dfwb.generateSeries({\n\t\t\tdelta: row => calculateChange(row.baseline, row.value)\n\t\t});\n\t\treturn new Timeseries(dfwb);\n\t}\n}\nexport default Timeseries;\n"],"names":["valueFiller","fillType","value","startValue","endValue","entryIndex","numEntries","overrideValue","dateFunction","date","flag","indexOf","Error","fromPairs","toPairs","map","key","rval","df","values","deflate","row","x","toArray","std","sampleStandardDeviation","mean","_mean","ndf","generateSeries","ares","R","DataFrame","Math","abs","max","lambdaTest","n","i","alpha","p","pValue","t","degreeOfFreedom","Studentt","inv","tValue","lambda","sqrt","pow","modz","mad","median","modifiedZScoreTest","_median","medianAbsoluteDeviation","outliers","sort","a","b","filter","v","thresholds","upper","min","Infinity","lower","Timeseries","data","config","others","dayjs","valueOf","index","toDate","considerAllRows","dateRange","unit","adjustment","start","this","first","end","last","startOf","endOf","diff","at","calculateThresholds","q1","q3","iqr","k","filterZeros","filterNegative","noflags","where","Array","isArray","length","isNaN","getSeries","count","floor","esd","dataset","newdf","dataframe","trip","pair","Object","assign","Value","push","outlierValues","outlier","takeWhile","iterations","rosnerTest","box","quantile","lowerInner","upperInner","lowerOuter","upperOuter","calculateStatistics","column","series","average","dataQuality","transformAll","adjustmentFunction","columns","detectTypes","Type","distinct","Column","forEach","col","transformSeries","removeOutliers","lowerThreshold","upperThreshold","outlierCheck","raw","reset","withSeries","dropSeries","group","interval","groupBy","resample","duration","isEqual","d0","add","downsample","upsample","fillGaps","durationValue","pairA","pairB","startDate","gapExists","endDate","newEntries","e","gapFill","dateComparison","valueColumns","select","sum","getColumnNames","inflate","withIndex","populate","type","getIndex","fill","console","time","bdf","blank","timeEnd","joinOuterRight","origional","reduceToValue","columnNames","chooseValue","subset","clean","columnName","undefined","error","dates","intervalToMS","log","aggregate","dataframes","concat","o","c","annualMonthlyAverage","between","annualIntensity","normalizeValue","year","scaler","_this2","renameSeries","addBaselineDelta","baselineDF","dfwb","indexer","baselineInterval","month","indexedBaseline","baseline","has","delta","ms","window","detectValues","orderBy","Frequency","ceil"],"mappings":"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"}